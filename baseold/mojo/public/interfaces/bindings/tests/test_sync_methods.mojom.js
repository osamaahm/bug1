// mojo/public/interfaces/bindings/tests/test_sync_methods.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'mojo/public/interfaces/bindings/tests/test_sync_methods.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('mojo.test');



  function TestSyncCodeGeneration_NoInput_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoInput_Params.prototype.initDefaults_ = function() {
  };
  TestSyncCodeGeneration_NoInput_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoInput_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoInput_Params.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncCodeGeneration_NoInput_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoInput_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncCodeGeneration_NoInput_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoInput_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncCodeGeneration_NoInput_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoInput_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  TestSyncCodeGeneration_NoInput_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoInput_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoInput_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncCodeGeneration_NoInput_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoInput_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncCodeGeneration_NoInput_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoInput_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncCodeGeneration_NoOutput_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoOutput_Params.prototype.initDefaults_ = function() {
    this.value = 0;
  };
  TestSyncCodeGeneration_NoOutput_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoOutput_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoOutput_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncCodeGeneration_NoOutput_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoOutput_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncCodeGeneration_NoOutput_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoOutput_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncCodeGeneration_NoOutput_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoOutput_ResponseParams.prototype.initDefaults_ = function() {
  };
  TestSyncCodeGeneration_NoOutput_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoOutput_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoOutput_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncCodeGeneration_NoOutput_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoOutput_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncCodeGeneration_NoOutput_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoOutput_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncCodeGeneration_NoInOut_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoInOut_Params.prototype.initDefaults_ = function() {
  };
  TestSyncCodeGeneration_NoInOut_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoInOut_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoInOut_Params.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncCodeGeneration_NoInOut_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoInOut_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncCodeGeneration_NoInOut_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoInOut_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncCodeGeneration_NoInOut_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_NoInOut_ResponseParams.prototype.initDefaults_ = function() {
  };
  TestSyncCodeGeneration_NoInOut_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_NoInOut_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_NoInOut_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncCodeGeneration_NoInOut_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_NoInOut_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncCodeGeneration_NoInOut_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_NoInOut_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncCodeGeneration_HaveInOut_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_HaveInOut_Params.prototype.initDefaults_ = function() {
    this.value1 = 0;
    this.value2 = 0;
  };
  TestSyncCodeGeneration_HaveInOut_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_HaveInOut_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_HaveInOut_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncCodeGeneration_HaveInOut_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_HaveInOut_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value1 = decoder.decodeStruct(codec.Int32);
    val.value2 = decoder.decodeStruct(codec.Int32);
    return val;
  };

  TestSyncCodeGeneration_HaveInOut_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_HaveInOut_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value1);
    encoder.encodeStruct(codec.Int32, val.value2);
  };
  function TestSyncCodeGeneration_HaveInOut_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncCodeGeneration_HaveInOut_ResponseParams.prototype.initDefaults_ = function() {
    this.result1 = 0;
    this.result2 = 0;
  };
  TestSyncCodeGeneration_HaveInOut_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncCodeGeneration_HaveInOut_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  TestSyncCodeGeneration_HaveInOut_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncCodeGeneration_HaveInOut_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncCodeGeneration_HaveInOut_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result1 = decoder.decodeStruct(codec.Int32);
    val.result2 = decoder.decodeStruct(codec.Int32);
    return val;
  };

  TestSyncCodeGeneration_HaveInOut_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncCodeGeneration_HaveInOut_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result1);
    encoder.encodeStruct(codec.Int32, val.result2);
  };
  function TestSync_Ping_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_Ping_Params.prototype.initDefaults_ = function() {
  };
  TestSync_Ping_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_Ping_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSync_Ping_Params.encodedSize = codec.kStructHeaderSize + 0;

  TestSync_Ping_Params.decode = function(decoder) {
    var packed;
    var val = new TestSync_Ping_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSync_Ping_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_Ping_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSync_Ping_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_Ping_ResponseParams.prototype.initDefaults_ = function() {
  };
  TestSync_Ping_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_Ping_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSync_Ping_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  TestSync_Ping_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSync_Ping_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSync_Ping_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_Ping_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSync_Echo_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_Echo_Params.prototype.initDefaults_ = function() {
    this.value = 0;
  };
  TestSync_Echo_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_Echo_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSync_Echo_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSync_Echo_Params.decode = function(decoder) {
    var packed;
    var val = new TestSync_Echo_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSync_Echo_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_Echo_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSync_Echo_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_Echo_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  TestSync_Echo_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_Echo_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSync_Echo_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSync_Echo_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSync_Echo_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSync_Echo_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_Echo_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSync_AsyncEcho_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_AsyncEcho_Params.prototype.initDefaults_ = function() {
    this.value = 0;
  };
  TestSync_AsyncEcho_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_AsyncEcho_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSync_AsyncEcho_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSync_AsyncEcho_Params.decode = function(decoder) {
    var packed;
    var val = new TestSync_AsyncEcho_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSync_AsyncEcho_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_AsyncEcho_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSync_AsyncEcho_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSync_AsyncEcho_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  TestSync_AsyncEcho_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSync_AsyncEcho_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSync_AsyncEcho_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSync_AsyncEcho_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSync_AsyncEcho_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSync_AsyncEcho_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSync_AsyncEcho_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncMaster_Ping_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_Ping_Params.prototype.initDefaults_ = function() {
  };
  TestSyncMaster_Ping_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_Ping_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncMaster_Ping_Params.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncMaster_Ping_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_Ping_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncMaster_Ping_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_Ping_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncMaster_Ping_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_Ping_ResponseParams.prototype.initDefaults_ = function() {
  };
  TestSyncMaster_Ping_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_Ping_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncMaster_Ping_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  TestSyncMaster_Ping_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_Ping_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  TestSyncMaster_Ping_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_Ping_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function TestSyncMaster_Echo_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_Echo_Params.prototype.initDefaults_ = function() {
    this.value = 0;
  };
  TestSyncMaster_Echo_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_Echo_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncMaster_Echo_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_Echo_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_Echo_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncMaster_Echo_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_Echo_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncMaster_Echo_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_Echo_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  TestSyncMaster_Echo_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_Echo_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncMaster_Echo_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_Echo_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_Echo_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncMaster_Echo_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_Echo_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncMaster_AsyncEcho_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_AsyncEcho_Params.prototype.initDefaults_ = function() {
    this.value = 0;
  };
  TestSyncMaster_AsyncEcho_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_AsyncEcho_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncMaster_AsyncEcho_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_AsyncEcho_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_AsyncEcho_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncMaster_AsyncEcho_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_AsyncEcho_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.value);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncMaster_AsyncEcho_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_AsyncEcho_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  TestSyncMaster_AsyncEcho_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_AsyncEcho_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  TestSyncMaster_AsyncEcho_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_AsyncEcho_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_AsyncEcho_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncMaster_AsyncEcho_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_AsyncEcho_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TestSyncMaster_SendRemote_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_SendRemote_Params.prototype.initDefaults_ = function() {
    this.remote = new associatedBindings.AssociatedInterfacePtrInfo();
  };
  TestSyncMaster_SendRemote_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_SendRemote_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TestSyncMaster_SendRemote_Params.remote
    err = messageValidator.validateAssociatedInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncMaster_SendRemote_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_SendRemote_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_SendRemote_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.remote = decoder.decodeStruct(codec.AssociatedInterfacePtrInfo);
    return val;
  };

  TestSyncMaster_SendRemote_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_SendRemote_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.AssociatedInterfacePtrInfo, val.remote);
  };
  function TestSyncMaster_SendReceiver_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TestSyncMaster_SendReceiver_Params.prototype.initDefaults_ = function() {
    this.receiver = new associatedBindings.AssociatedInterfaceRequest();
  };
  TestSyncMaster_SendReceiver_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TestSyncMaster_SendReceiver_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TestSyncMaster_SendReceiver_Params.receiver
    err = messageValidator.validateAssociatedInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TestSyncMaster_SendReceiver_Params.encodedSize = codec.kStructHeaderSize + 8;

  TestSyncMaster_SendReceiver_Params.decode = function(decoder) {
    var packed;
    var val = new TestSyncMaster_SendReceiver_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver = decoder.decodeStruct(codec.AssociatedInterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  TestSyncMaster_SendReceiver_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TestSyncMaster_SendReceiver_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.AssociatedInterfaceRequest, val.receiver);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  var kTestSyncCodeGeneration_NoInput_Name = 0;
  var kTestSyncCodeGeneration_NoOutput_Name = 1;
  var kTestSyncCodeGeneration_NoInOut_Name = 2;
  var kTestSyncCodeGeneration_HaveInOut_Name = 3;

  function TestSyncCodeGenerationPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(TestSyncCodeGeneration,
                                                   handleOrPtrInfo);
  }

  function TestSyncCodeGenerationAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        TestSyncCodeGeneration, associatedInterfacePtrInfo);
  }

  TestSyncCodeGenerationAssociatedPtr.prototype =
      Object.create(TestSyncCodeGenerationPtr.prototype);
  TestSyncCodeGenerationAssociatedPtr.prototype.constructor =
      TestSyncCodeGenerationAssociatedPtr;

  function TestSyncCodeGenerationProxy(receiver) {
    this.receiver_ = receiver;
  }
  TestSyncCodeGenerationPtr.prototype.noInput = function() {
    return TestSyncCodeGenerationProxy.prototype.noInput
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncCodeGenerationProxy.prototype.noInput = function() {
    var params_ = new TestSyncCodeGeneration_NoInput_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncCodeGeneration_NoInput_Name,
          codec.align(TestSyncCodeGeneration_NoInput_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncCodeGeneration_NoInput_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncCodeGeneration_NoInput_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncCodeGenerationPtr.prototype.noOutput = function() {
    return TestSyncCodeGenerationProxy.prototype.noOutput
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncCodeGenerationProxy.prototype.noOutput = function(value) {
    var params_ = new TestSyncCodeGeneration_NoOutput_Params();
    params_.value = value;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncCodeGeneration_NoOutput_Name,
          codec.align(TestSyncCodeGeneration_NoOutput_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncCodeGeneration_NoOutput_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncCodeGeneration_NoOutput_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncCodeGenerationPtr.prototype.noInOut = function() {
    return TestSyncCodeGenerationProxy.prototype.noInOut
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncCodeGenerationProxy.prototype.noInOut = function() {
    var params_ = new TestSyncCodeGeneration_NoInOut_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncCodeGeneration_NoInOut_Name,
          codec.align(TestSyncCodeGeneration_NoInOut_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncCodeGeneration_NoInOut_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncCodeGeneration_NoInOut_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncCodeGenerationPtr.prototype.haveInOut = function() {
    return TestSyncCodeGenerationProxy.prototype.haveInOut
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncCodeGenerationProxy.prototype.haveInOut = function(value1, value2) {
    var params_ = new TestSyncCodeGeneration_HaveInOut_Params();
    params_.value1 = value1;
    params_.value2 = value2;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncCodeGeneration_HaveInOut_Name,
          codec.align(TestSyncCodeGeneration_HaveInOut_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncCodeGeneration_HaveInOut_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncCodeGeneration_HaveInOut_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function TestSyncCodeGenerationStub(delegate) {
    this.delegate_ = delegate;
  }
  TestSyncCodeGenerationStub.prototype.noInput = function() {
    return this.delegate_ && this.delegate_.noInput && this.delegate_.noInput();
  }
  TestSyncCodeGenerationStub.prototype.noOutput = function(value) {
    return this.delegate_ && this.delegate_.noOutput && this.delegate_.noOutput(value);
  }
  TestSyncCodeGenerationStub.prototype.noInOut = function() {
    return this.delegate_ && this.delegate_.noInOut && this.delegate_.noInOut();
  }
  TestSyncCodeGenerationStub.prototype.haveInOut = function(value1, value2) {
    return this.delegate_ && this.delegate_.haveInOut && this.delegate_.haveInOut(value1, value2);
  }

  TestSyncCodeGenerationStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  TestSyncCodeGenerationStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kTestSyncCodeGeneration_NoInput_Name:
      var params = reader.decodeStruct(TestSyncCodeGeneration_NoInput_Params);
      this.noInput().then(function(response) {
        var responseParams =
            new TestSyncCodeGeneration_NoInput_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kTestSyncCodeGeneration_NoInput_Name,
            codec.align(TestSyncCodeGeneration_NoInput_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncCodeGeneration_NoInput_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSyncCodeGeneration_NoOutput_Name:
      var params = reader.decodeStruct(TestSyncCodeGeneration_NoOutput_Params);
      this.noOutput(params.value).then(function(response) {
        var responseParams =
            new TestSyncCodeGeneration_NoOutput_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kTestSyncCodeGeneration_NoOutput_Name,
            codec.align(TestSyncCodeGeneration_NoOutput_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncCodeGeneration_NoOutput_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSyncCodeGeneration_NoInOut_Name:
      var params = reader.decodeStruct(TestSyncCodeGeneration_NoInOut_Params);
      this.noInOut().then(function(response) {
        var responseParams =
            new TestSyncCodeGeneration_NoInOut_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kTestSyncCodeGeneration_NoInOut_Name,
            codec.align(TestSyncCodeGeneration_NoInOut_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncCodeGeneration_NoInOut_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSyncCodeGeneration_HaveInOut_Name:
      var params = reader.decodeStruct(TestSyncCodeGeneration_HaveInOut_Params);
      this.haveInOut(params.value1, params.value2).then(function(response) {
        var responseParams =
            new TestSyncCodeGeneration_HaveInOut_ResponseParams();
        responseParams.result1 = response.result1;
        responseParams.result2 = response.result2;
        var builder = new codec.MessageV1Builder(
            kTestSyncCodeGeneration_HaveInOut_Name,
            codec.align(TestSyncCodeGeneration_HaveInOut_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncCodeGeneration_HaveInOut_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateTestSyncCodeGenerationRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kTestSyncCodeGeneration_NoInput_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncCodeGeneration_NoInput_Params;
      break;
      case kTestSyncCodeGeneration_NoOutput_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncCodeGeneration_NoOutput_Params;
      break;
      case kTestSyncCodeGeneration_NoInOut_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncCodeGeneration_NoInOut_Params;
      break;
      case kTestSyncCodeGeneration_HaveInOut_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncCodeGeneration_HaveInOut_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateTestSyncCodeGenerationResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kTestSyncCodeGeneration_NoInput_Name:
        if (message.isResponse())
          paramsClass = TestSyncCodeGeneration_NoInput_ResponseParams;
        break;
      case kTestSyncCodeGeneration_NoOutput_Name:
        if (message.isResponse())
          paramsClass = TestSyncCodeGeneration_NoOutput_ResponseParams;
        break;
      case kTestSyncCodeGeneration_NoInOut_Name:
        if (message.isResponse())
          paramsClass = TestSyncCodeGeneration_NoInOut_ResponseParams;
        break;
      case kTestSyncCodeGeneration_HaveInOut_Name:
        if (message.isResponse())
          paramsClass = TestSyncCodeGeneration_HaveInOut_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var TestSyncCodeGeneration = {
    name: 'mojo.test.TestSyncCodeGeneration',
    kVersion: 0,
    ptrClass: TestSyncCodeGenerationPtr,
    proxyClass: TestSyncCodeGenerationProxy,
    stubClass: TestSyncCodeGenerationStub,
    validateRequest: validateTestSyncCodeGenerationRequest,
    validateResponse: validateTestSyncCodeGenerationResponse,
  };
  TestSyncCodeGenerationStub.prototype.validator = validateTestSyncCodeGenerationRequest;
  TestSyncCodeGenerationProxy.prototype.validator = validateTestSyncCodeGenerationResponse;
  var kTestSync_Ping_Name = 0;
  var kTestSync_Echo_Name = 1;
  var kTestSync_AsyncEcho_Name = 2;

  function TestSyncPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(TestSync,
                                                   handleOrPtrInfo);
  }

  function TestSyncAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        TestSync, associatedInterfacePtrInfo);
  }

  TestSyncAssociatedPtr.prototype =
      Object.create(TestSyncPtr.prototype);
  TestSyncAssociatedPtr.prototype.constructor =
      TestSyncAssociatedPtr;

  function TestSyncProxy(receiver) {
    this.receiver_ = receiver;
  }
  TestSyncPtr.prototype.ping = function() {
    return TestSyncProxy.prototype.ping
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncProxy.prototype.ping = function() {
    var params_ = new TestSync_Ping_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSync_Ping_Name,
          codec.align(TestSync_Ping_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSync_Ping_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSync_Ping_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncPtr.prototype.echo = function() {
    return TestSyncProxy.prototype.echo
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncProxy.prototype.echo = function(value) {
    var params_ = new TestSync_Echo_Params();
    params_.value = value;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSync_Echo_Name,
          codec.align(TestSync_Echo_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSync_Echo_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSync_Echo_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncPtr.prototype.asyncEcho = function() {
    return TestSyncProxy.prototype.asyncEcho
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncProxy.prototype.asyncEcho = function(value) {
    var params_ = new TestSync_AsyncEcho_Params();
    params_.value = value;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSync_AsyncEcho_Name,
          codec.align(TestSync_AsyncEcho_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSync_AsyncEcho_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSync_AsyncEcho_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function TestSyncStub(delegate) {
    this.delegate_ = delegate;
  }
  TestSyncStub.prototype.ping = function() {
    return this.delegate_ && this.delegate_.ping && this.delegate_.ping();
  }
  TestSyncStub.prototype.echo = function(value) {
    return this.delegate_ && this.delegate_.echo && this.delegate_.echo(value);
  }
  TestSyncStub.prototype.asyncEcho = function(value) {
    return this.delegate_ && this.delegate_.asyncEcho && this.delegate_.asyncEcho(value);
  }

  TestSyncStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  TestSyncStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kTestSync_Ping_Name:
      var params = reader.decodeStruct(TestSync_Ping_Params);
      this.ping().then(function(response) {
        var responseParams =
            new TestSync_Ping_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kTestSync_Ping_Name,
            codec.align(TestSync_Ping_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSync_Ping_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSync_Echo_Name:
      var params = reader.decodeStruct(TestSync_Echo_Params);
      this.echo(params.value).then(function(response) {
        var responseParams =
            new TestSync_Echo_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kTestSync_Echo_Name,
            codec.align(TestSync_Echo_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSync_Echo_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSync_AsyncEcho_Name:
      var params = reader.decodeStruct(TestSync_AsyncEcho_Params);
      this.asyncEcho(params.value).then(function(response) {
        var responseParams =
            new TestSync_AsyncEcho_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kTestSync_AsyncEcho_Name,
            codec.align(TestSync_AsyncEcho_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSync_AsyncEcho_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateTestSyncRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kTestSync_Ping_Name:
        if (message.expectsResponse())
          paramsClass = TestSync_Ping_Params;
      break;
      case kTestSync_Echo_Name:
        if (message.expectsResponse())
          paramsClass = TestSync_Echo_Params;
      break;
      case kTestSync_AsyncEcho_Name:
        if (message.expectsResponse())
          paramsClass = TestSync_AsyncEcho_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateTestSyncResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kTestSync_Ping_Name:
        if (message.isResponse())
          paramsClass = TestSync_Ping_ResponseParams;
        break;
      case kTestSync_Echo_Name:
        if (message.isResponse())
          paramsClass = TestSync_Echo_ResponseParams;
        break;
      case kTestSync_AsyncEcho_Name:
        if (message.isResponse())
          paramsClass = TestSync_AsyncEcho_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var TestSync = {
    name: 'mojo.test.TestSync',
    kVersion: 0,
    ptrClass: TestSyncPtr,
    proxyClass: TestSyncProxy,
    stubClass: TestSyncStub,
    validateRequest: validateTestSyncRequest,
    validateResponse: validateTestSyncResponse,
  };
  TestSyncStub.prototype.validator = validateTestSyncRequest;
  TestSyncProxy.prototype.validator = validateTestSyncResponse;
  var kTestSyncMaster_Ping_Name = 0;
  var kTestSyncMaster_Echo_Name = 1;
  var kTestSyncMaster_AsyncEcho_Name = 2;
  var kTestSyncMaster_SendRemote_Name = 3;
  var kTestSyncMaster_SendReceiver_Name = 4;

  function TestSyncMasterPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(TestSyncMaster,
                                                   handleOrPtrInfo);
  }

  function TestSyncMasterAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        TestSyncMaster, associatedInterfacePtrInfo);
  }

  TestSyncMasterAssociatedPtr.prototype =
      Object.create(TestSyncMasterPtr.prototype);
  TestSyncMasterAssociatedPtr.prototype.constructor =
      TestSyncMasterAssociatedPtr;

  function TestSyncMasterProxy(receiver) {
    this.receiver_ = receiver;
  }
  TestSyncMasterPtr.prototype.ping = function() {
    return TestSyncMasterProxy.prototype.ping
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncMasterProxy.prototype.ping = function() {
    var params_ = new TestSyncMaster_Ping_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncMaster_Ping_Name,
          codec.align(TestSyncMaster_Ping_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncMaster_Ping_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncMaster_Ping_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncMasterPtr.prototype.echo = function() {
    return TestSyncMasterProxy.prototype.echo
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncMasterProxy.prototype.echo = function(value) {
    var params_ = new TestSyncMaster_Echo_Params();
    params_.value = value;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncMaster_Echo_Name,
          codec.align(TestSyncMaster_Echo_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncMaster_Echo_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncMaster_Echo_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncMasterPtr.prototype.asyncEcho = function() {
    return TestSyncMasterProxy.prototype.asyncEcho
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncMasterProxy.prototype.asyncEcho = function(value) {
    var params_ = new TestSyncMaster_AsyncEcho_Params();
    params_.value = value;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kTestSyncMaster_AsyncEcho_Name,
          codec.align(TestSyncMaster_AsyncEcho_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(TestSyncMaster_AsyncEcho_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(TestSyncMaster_AsyncEcho_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  TestSyncMasterPtr.prototype.sendRemote = function() {
    return TestSyncMasterProxy.prototype.sendRemote
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncMasterProxy.prototype.sendRemote = function(remote) {
    var params_ = new TestSyncMaster_SendRemote_Params();
    params_.remote = remote;
    var builder = new codec.MessageV2Builder(
        kTestSyncMaster_SendRemote_Name,
        codec.align(TestSyncMaster_SendRemote_Params.encodedSize));
    builder.setPayload(TestSyncMaster_SendRemote_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  TestSyncMasterPtr.prototype.sendReceiver = function() {
    return TestSyncMasterProxy.prototype.sendReceiver
        .apply(this.ptr.getProxy(), arguments);
  };

  TestSyncMasterProxy.prototype.sendReceiver = function(receiver) {
    var params_ = new TestSyncMaster_SendReceiver_Params();
    params_.receiver = receiver;
    var builder = new codec.MessageV2Builder(
        kTestSyncMaster_SendReceiver_Name,
        codec.align(TestSyncMaster_SendReceiver_Params.encodedSize));
    builder.setPayload(TestSyncMaster_SendReceiver_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function TestSyncMasterStub(delegate) {
    this.delegate_ = delegate;
  }
  TestSyncMasterStub.prototype.ping = function() {
    return this.delegate_ && this.delegate_.ping && this.delegate_.ping();
  }
  TestSyncMasterStub.prototype.echo = function(value) {
    return this.delegate_ && this.delegate_.echo && this.delegate_.echo(value);
  }
  TestSyncMasterStub.prototype.asyncEcho = function(value) {
    return this.delegate_ && this.delegate_.asyncEcho && this.delegate_.asyncEcho(value);
  }
  TestSyncMasterStub.prototype.sendRemote = function(remote) {
    return this.delegate_ && this.delegate_.sendRemote && this.delegate_.sendRemote(remote);
  }
  TestSyncMasterStub.prototype.sendReceiver = function(receiver) {
    return this.delegate_ && this.delegate_.sendReceiver && this.delegate_.sendReceiver(receiver);
  }

  TestSyncMasterStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kTestSyncMaster_SendRemote_Name:
      var params = reader.decodeStruct(TestSyncMaster_SendRemote_Params);
      this.sendRemote(params.remote);
      return true;
    case kTestSyncMaster_SendReceiver_Name:
      var params = reader.decodeStruct(TestSyncMaster_SendReceiver_Params);
      this.sendReceiver(params.receiver);
      return true;
    default:
      return false;
    }
  };

  TestSyncMasterStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kTestSyncMaster_Ping_Name:
      var params = reader.decodeStruct(TestSyncMaster_Ping_Params);
      this.ping().then(function(response) {
        var responseParams =
            new TestSyncMaster_Ping_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kTestSyncMaster_Ping_Name,
            codec.align(TestSyncMaster_Ping_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncMaster_Ping_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSyncMaster_Echo_Name:
      var params = reader.decodeStruct(TestSyncMaster_Echo_Params);
      this.echo(params.value).then(function(response) {
        var responseParams =
            new TestSyncMaster_Echo_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kTestSyncMaster_Echo_Name,
            codec.align(TestSyncMaster_Echo_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncMaster_Echo_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kTestSyncMaster_AsyncEcho_Name:
      var params = reader.decodeStruct(TestSyncMaster_AsyncEcho_Params);
      this.asyncEcho(params.value).then(function(response) {
        var responseParams =
            new TestSyncMaster_AsyncEcho_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kTestSyncMaster_AsyncEcho_Name,
            codec.align(TestSyncMaster_AsyncEcho_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(TestSyncMaster_AsyncEcho_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateTestSyncMasterRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kTestSyncMaster_Ping_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncMaster_Ping_Params;
      break;
      case kTestSyncMaster_Echo_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncMaster_Echo_Params;
      break;
      case kTestSyncMaster_AsyncEcho_Name:
        if (message.expectsResponse())
          paramsClass = TestSyncMaster_AsyncEcho_Params;
      break;
      case kTestSyncMaster_SendRemote_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = TestSyncMaster_SendRemote_Params;
      break;
      case kTestSyncMaster_SendReceiver_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = TestSyncMaster_SendReceiver_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateTestSyncMasterResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kTestSyncMaster_Ping_Name:
        if (message.isResponse())
          paramsClass = TestSyncMaster_Ping_ResponseParams;
        break;
      case kTestSyncMaster_Echo_Name:
        if (message.isResponse())
          paramsClass = TestSyncMaster_Echo_ResponseParams;
        break;
      case kTestSyncMaster_AsyncEcho_Name:
        if (message.isResponse())
          paramsClass = TestSyncMaster_AsyncEcho_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var TestSyncMaster = {
    name: 'mojo.test.TestSyncMaster',
    kVersion: 0,
    ptrClass: TestSyncMasterPtr,
    proxyClass: TestSyncMasterProxy,
    stubClass: TestSyncMasterStub,
    validateRequest: validateTestSyncMasterRequest,
    validateResponse: validateTestSyncMasterResponse,
  };
  TestSyncMasterStub.prototype.validator = validateTestSyncMasterRequest;
  TestSyncMasterProxy.prototype.validator = validateTestSyncMasterResponse;
  exports.TestSyncCodeGeneration = TestSyncCodeGeneration;
  exports.TestSyncCodeGenerationPtr = TestSyncCodeGenerationPtr;
  exports.TestSyncCodeGenerationAssociatedPtr = TestSyncCodeGenerationAssociatedPtr;
  exports.TestSync = TestSync;
  exports.TestSyncPtr = TestSyncPtr;
  exports.TestSyncAssociatedPtr = TestSyncAssociatedPtr;
  exports.TestSyncMaster = TestSyncMaster;
  exports.TestSyncMasterPtr = TestSyncMasterPtr;
  exports.TestSyncMasterAssociatedPtr = TestSyncMasterAssociatedPtr;
})();