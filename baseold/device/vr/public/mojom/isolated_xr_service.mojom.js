// device/vr/public/mojom/isolated_xr_service.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'device/vr/public/mojom/isolated_xr_service.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('device.mojom');
  var browser_test_interfaces$ =
      mojo.internal.exposeNamespace('deviceTest.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'device/vr/public/mojom/browser_test_interfaces.mojom', 'browser_test_interfaces.mojom.js');
  }
  var vr_service$ =
      mojo.internal.exposeNamespace('device.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'device/vr/public/mojom/vr_service.mojom', 'vr_service.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../../mojo/public/mojom/base/time.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }



  function XRRuntimeSessionOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeSessionOptions.prototype.initDefaults_ = function() {
    this.immersive = false;
    this.environmentIntegration = false;
    this.isLegacyWebvr = false;
    this.renderProcessId = 0;
    this.enabledFeatures = null;
    this.renderFrameId = 0;
  };
  XRRuntimeSessionOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeSessionOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // validate XRRuntimeSessionOptions.enabledFeatures
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, new codec.Enum(vr_service$.XRSessionFeature), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  XRRuntimeSessionOptions.encodedSize = codec.kStructHeaderSize + 24;

  XRRuntimeSessionOptions.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeSessionOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.immersive = (packed >> 0) & 1 ? true : false;
    val.environmentIntegration = (packed >> 1) & 1 ? true : false;
    val.isLegacyWebvr = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.renderProcessId = decoder.decodeStruct(codec.Int32);
    val.enabledFeatures = decoder.decodeArrayPointer(new codec.Enum(vr_service$.XRSessionFeature));
    val.renderFrameId = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntimeSessionOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeSessionOptions.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.immersive & 1) << 0
    packed |= (val.environmentIntegration & 1) << 1
    packed |= (val.isLegacyWebvr & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.renderProcessId);
    encoder.encodeArrayPointer(new codec.Enum(vr_service$.XRSessionFeature), val.enabledFeatures);
    encoder.encodeStruct(codec.Int32, val.renderFrameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRGamepadButton(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRGamepadButton.prototype.initDefaults_ = function() {
    this.pressed = false;
    this.touched = false;
    this.value = 0;
  };
  XRGamepadButton.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRGamepadButton.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  XRGamepadButton.encodedSize = codec.kStructHeaderSize + 16;

  XRGamepadButton.decode = function(decoder) {
    var packed;
    var val = new XRGamepadButton();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.pressed = (packed >> 0) & 1 ? true : false;
    val.touched = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.value = decoder.decodeStruct(codec.Double);
    return val;
  };

  XRGamepadButton.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRGamepadButton.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.pressed & 1) << 0
    packed |= (val.touched & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Double, val.value);
  };
  function XRGamepad(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRGamepad.prototype.initDefaults_ = function() {
    this.canProvideOrientation = false;
    this.canProvidePosition = false;
    this.hand = 0;
    this.axes = null;
    this.buttons = null;
    this.pose = null;
    this.controllerId = 0;
    this.timestamp = null;
  };
  XRGamepad.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRGamepad.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // validate XRGamepad.axes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, codec.Double, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRGamepad.buttons
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(XRGamepadButton), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRGamepad.pose
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, vr_service$.VRPose, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRGamepad.hand
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, vr_service$.XRHandedness);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRGamepad.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeTicks, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRGamepad.encodedSize = codec.kStructHeaderSize + 48;

  XRGamepad.decode = function(decoder) {
    var packed;
    var val = new XRGamepad();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.canProvideOrientation = (packed >> 0) & 1 ? true : false;
    val.canProvidePosition = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.hand = decoder.decodeStruct(codec.Int32);
    val.axes = decoder.decodeArrayPointer(codec.Double);
    val.buttons = decoder.decodeArrayPointer(new codec.PointerTo(XRGamepadButton));
    val.pose = decoder.decodeStructPointer(vr_service$.VRPose);
    val.controllerId = decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.timestamp = decoder.decodeStructPointer(time$.TimeTicks);
    return val;
  };

  XRGamepad.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRGamepad.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.canProvideOrientation & 1) << 0
    packed |= (val.canProvidePosition & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.hand);
    encoder.encodeArrayPointer(codec.Double, val.axes);
    encoder.encodeArrayPointer(new codec.PointerTo(XRGamepadButton), val.buttons);
    encoder.encodeStructPointer(vr_service$.VRPose, val.pose);
    encoder.encodeStruct(codec.Uint32, val.controllerId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(time$.TimeTicks, val.timestamp);
  };
  function XRGamepadData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRGamepadData.prototype.initDefaults_ = function() {
    this.gamepads = null;
  };
  XRGamepadData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRGamepadData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRGamepadData.gamepads
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(XRGamepad), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRGamepadData.encodedSize = codec.kStructHeaderSize + 8;

  XRGamepadData.decode = function(decoder) {
    var packed;
    var val = new XRGamepadData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.gamepads = decoder.decodeArrayPointer(new codec.PointerTo(XRGamepad));
    return val;
  };

  XRGamepadData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRGamepadData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(XRGamepad), val.gamepads);
  };
  function XRSessionController_SetFrameDataRestricted_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSessionController_SetFrameDataRestricted_Params.prototype.initDefaults_ = function() {
    this.restricted = false;
  };
  XRSessionController_SetFrameDataRestricted_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSessionController_SetFrameDataRestricted_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRSessionController_SetFrameDataRestricted_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRSessionController_SetFrameDataRestricted_Params.decode = function(decoder) {
    var packed;
    var val = new XRSessionController_SetFrameDataRestricted_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.restricted = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRSessionController_SetFrameDataRestricted_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSessionController_SetFrameDataRestricted_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.restricted & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntimeEventListener_OnDisplayInfoChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnDisplayInfoChanged_Params.prototype.initDefaults_ = function() {
    this.displayInfo = null;
  };
  XRRuntimeEventListener_OnDisplayInfoChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnDisplayInfoChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntimeEventListener_OnDisplayInfoChanged_Params.displayInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, vr_service$.VRDisplayInfo, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnDisplayInfoChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntimeEventListener_OnDisplayInfoChanged_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnDisplayInfoChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.displayInfo = decoder.decodeStructPointer(vr_service$.VRDisplayInfo);
    return val;
  };

  XRRuntimeEventListener_OnDisplayInfoChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnDisplayInfoChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(vr_service$.VRDisplayInfo, val.displayInfo);
  };
  function XRRuntimeEventListener_OnDeviceActivated_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnDeviceActivated_Params.prototype.initDefaults_ = function() {
    this.reason = 0;
  };
  XRRuntimeEventListener_OnDeviceActivated_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnDeviceActivated_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntimeEventListener_OnDeviceActivated_Params.reason
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, vr_service$.VRDisplayEventReason);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnDeviceActivated_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntimeEventListener_OnDeviceActivated_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnDeviceActivated_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.reason = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntimeEventListener_OnDeviceActivated_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnDeviceActivated_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.reason);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntimeEventListener_OnDeviceActivated_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.prototype.initDefaults_ = function() {
    this.willNotPresent = false;
  };
  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnDeviceActivated_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.willNotPresent = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntimeEventListener_OnDeviceActivated_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnDeviceActivated_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.willNotPresent & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntimeEventListener_OnDeviceIdle_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnDeviceIdle_Params.prototype.initDefaults_ = function() {
    this.reason = 0;
  };
  XRRuntimeEventListener_OnDeviceIdle_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnDeviceIdle_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntimeEventListener_OnDeviceIdle_Params.reason
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, vr_service$.VRDisplayEventReason);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnDeviceIdle_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntimeEventListener_OnDeviceIdle_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnDeviceIdle_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.reason = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntimeEventListener_OnDeviceIdle_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnDeviceIdle_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.reason);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntimeEventListener_OnVisibilityStateChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnVisibilityStateChanged_Params.prototype.initDefaults_ = function() {
    this.visibilityState = 0;
  };
  XRRuntimeEventListener_OnVisibilityStateChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnVisibilityStateChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntimeEventListener_OnVisibilityStateChanged_Params.visibilityState
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, vr_service$.XRVisibilityState);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnVisibilityStateChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntimeEventListener_OnVisibilityStateChanged_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnVisibilityStateChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.visibilityState = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntimeEventListener_OnVisibilityStateChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnVisibilityStateChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.visibilityState);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntimeEventListener_OnExitPresent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntimeEventListener_OnExitPresent_Params.prototype.initDefaults_ = function() {
  };
  XRRuntimeEventListener_OnExitPresent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntimeEventListener_OnExitPresent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntimeEventListener_OnExitPresent_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRRuntimeEventListener_OnExitPresent_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntimeEventListener_OnExitPresent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRRuntimeEventListener_OnExitPresent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntimeEventListener_OnExitPresent_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRRuntime_RequestSession_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_RequestSession_Params.prototype.initDefaults_ = function() {
    this.options = null;
  };
  XRRuntime_RequestSession_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_RequestSession_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntime_RequestSession_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRRuntimeSessionOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_RequestSession_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntime_RequestSession_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_RequestSession_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.options = decoder.decodeStructPointer(XRRuntimeSessionOptions);
    return val;
  };

  XRRuntime_RequestSession_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_RequestSession_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRRuntimeSessionOptions, val.options);
  };
  function XRRuntime_RequestSession_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_RequestSession_ResponseParams.prototype.initDefaults_ = function() {
    this.session = null;
    this.controller = new XRSessionControllerPtr();
  };
  XRRuntime_RequestSession_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_RequestSession_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntime_RequestSession_ResponseParams.session
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, vr_service$.XRSession, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntime_RequestSession_ResponseParams.controller
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 8, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_RequestSession_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  XRRuntime_RequestSession_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_RequestSession_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.session = decoder.decodeStructPointer(vr_service$.XRSession);
    val.controller = decoder.decodeStruct(new codec.NullableInterface(XRSessionControllerPtr));
    return val;
  };

  XRRuntime_RequestSession_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_RequestSession_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(vr_service$.XRSession, val.session);
    encoder.encodeStruct(new codec.NullableInterface(XRSessionControllerPtr), val.controller);
  };
  function XRRuntime_ListenToDeviceChanges_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_ListenToDeviceChanges_Params.prototype.initDefaults_ = function() {
    this.listener = new associatedBindings.AssociatedInterfacePtrInfo();
  };
  XRRuntime_ListenToDeviceChanges_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_ListenToDeviceChanges_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntime_ListenToDeviceChanges_Params.listener
    err = messageValidator.validateAssociatedInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_ListenToDeviceChanges_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntime_ListenToDeviceChanges_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_ListenToDeviceChanges_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.listener = decoder.decodeStruct(codec.AssociatedInterfacePtrInfo);
    return val;
  };

  XRRuntime_ListenToDeviceChanges_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_ListenToDeviceChanges_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.AssociatedInterfacePtrInfo, val.listener);
  };
  function XRRuntime_ListenToDeviceChanges_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_ListenToDeviceChanges_ResponseParams.prototype.initDefaults_ = function() {
    this.displayInfo = null;
  };
  XRRuntime_ListenToDeviceChanges_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_ListenToDeviceChanges_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRuntime_ListenToDeviceChanges_ResponseParams.displayInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, vr_service$.VRDisplayInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_ListenToDeviceChanges_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntime_ListenToDeviceChanges_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_ListenToDeviceChanges_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.displayInfo = decoder.decodeStructPointer(vr_service$.VRDisplayInfo);
    return val;
  };

  XRRuntime_ListenToDeviceChanges_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_ListenToDeviceChanges_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(vr_service$.VRDisplayInfo, val.displayInfo);
  };
  function XRRuntime_EnsureInitialized_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_EnsureInitialized_Params.prototype.initDefaults_ = function() {
  };
  XRRuntime_EnsureInitialized_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_EnsureInitialized_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_EnsureInitialized_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRRuntime_EnsureInitialized_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_EnsureInitialized_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRRuntime_EnsureInitialized_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_EnsureInitialized_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRRuntime_EnsureInitialized_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_EnsureInitialized_ResponseParams.prototype.initDefaults_ = function() {
  };
  XRRuntime_EnsureInitialized_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_EnsureInitialized_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRuntime_EnsureInitialized_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  XRRuntime_EnsureInitialized_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_EnsureInitialized_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRRuntime_EnsureInitialized_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_EnsureInitialized_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function XRRuntime_SetListeningForActivate_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_SetListeningForActivate_Params.prototype.initDefaults_ = function() {
    this.listenForActivation = false;
  };
  XRRuntime_SetListeningForActivate_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_SetListeningForActivate_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRRuntime_SetListeningForActivate_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntime_SetListeningForActivate_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_SetListeningForActivate_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.listenForActivation = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntime_SetListeningForActivate_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_SetListeningForActivate_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.listenForActivation & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRRuntime_SetInlinePosesEnabled_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRuntime_SetInlinePosesEnabled_Params.prototype.initDefaults_ = function() {
    this.enable = false;
  };
  XRRuntime_SetInlinePosesEnabled_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRuntime_SetInlinePosesEnabled_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRRuntime_SetInlinePosesEnabled_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRRuntime_SetInlinePosesEnabled_Params.decode = function(decoder) {
    var packed;
    var val = new XRRuntime_SetInlinePosesEnabled_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.enable = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRRuntime_SetInlinePosesEnabled_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRuntime_SetInlinePosesEnabled_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.enable & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IsolatedXRGamepadProvider_RequestUpdate_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRGamepadProvider_RequestUpdate_Params.prototype.initDefaults_ = function() {
  };
  IsolatedXRGamepadProvider_RequestUpdate_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRGamepadProvider_RequestUpdate_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRGamepadProvider_RequestUpdate_Params.encodedSize = codec.kStructHeaderSize + 0;

  IsolatedXRGamepadProvider_RequestUpdate_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRGamepadProvider_RequestUpdate_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  IsolatedXRGamepadProvider_RequestUpdate_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRGamepadProvider_RequestUpdate_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function IsolatedXRGamepadProvider_RequestUpdate_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.prototype.initDefaults_ = function() {
    this.data = null;
  };
  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRGamepadData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRGamepadProvider_RequestUpdate_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data = decoder.decodeStructPointer(XRGamepadData);
    return val;
  };

  IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRGamepadData, val.data);
  };
  function IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.prototype.initDefaults_ = function() {
    this.provider = new bindings.InterfaceRequest();
  };
  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.provider
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.encodedSize = codec.kStructHeaderSize + 8;

  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.provider = decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.provider);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ImmersiveOverlay_RequestNextOverlayPose_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_RequestNextOverlayPose_Params.prototype.initDefaults_ = function() {
  };
  ImmersiveOverlay_RequestNextOverlayPose_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_RequestNextOverlayPose_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ImmersiveOverlay_RequestNextOverlayPose_Params.encodedSize = codec.kStructHeaderSize + 0;

  ImmersiveOverlay_RequestNextOverlayPose_Params.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_RequestNextOverlayPose_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  ImmersiveOverlay_RequestNextOverlayPose_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_RequestNextOverlayPose_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function ImmersiveOverlay_RequestNextOverlayPose_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.prototype.initDefaults_ = function() {
    this.pose = null;
  };
  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.pose
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, vr_service$.XRFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_RequestNextOverlayPose_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pose = decoder.decodeStructPointer(vr_service$.XRFrameData);
    return val;
  };

  ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(vr_service$.XRFrameData, val.pose);
  };
  function ImmersiveOverlay_SubmitOverlayTexture_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_SubmitOverlayTexture_Params.prototype.initDefaults_ = function() {
    this.frameId = 0;
    this.texture = null;
    this.leftBounds = null;
    this.rightBounds = null;
  };
  ImmersiveOverlay_SubmitOverlayTexture_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_SubmitOverlayTexture_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate ImmersiveOverlay_SubmitOverlayTexture_Params.texture
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 4, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate ImmersiveOverlay_SubmitOverlayTexture_Params.leftBounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ImmersiveOverlay_SubmitOverlayTexture_Params.rightBounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ImmersiveOverlay_SubmitOverlayTexture_Params.encodedSize = codec.kStructHeaderSize + 24;

  ImmersiveOverlay_SubmitOverlayTexture_Params.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_SubmitOverlayTexture_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameId = decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    val.texture = decoder.decodeStruct(codec.Handle);
    val.leftBounds = decoder.decodeStructPointer(geometry$.RectF);
    val.rightBounds = decoder.decodeStructPointer(geometry$.RectF);
    return val;
  };

  ImmersiveOverlay_SubmitOverlayTexture_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_SubmitOverlayTexture_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Handle, val.texture);
    encoder.encodeStructPointer(geometry$.RectF, val.leftBounds);
    encoder.encodeStructPointer(geometry$.RectF, val.rightBounds);
  };
  function ImmersiveOverlay_SubmitOverlayTexture_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_SubmitOverlayTexture_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.prototype.initDefaults_ = function() {
    this.overlayVisible = false;
    this.webxrVisible = false;
  };
  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.encodedSize = codec.kStructHeaderSize + 8;

  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.overlayVisible = (packed >> 0) & 1 ? true : false;
    val.webxrVisible = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.overlayVisible & 1) << 0
    packed |= (val.webxrVisible & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.prototype.initDefaults_ = function() {
  };
  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.encodedSize = codec.kStructHeaderSize + 0;

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.prototype.initDefaults_ = function() {
  };
  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function XRCompositorHost_CreateImmersiveOverlay_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRCompositorHost_CreateImmersiveOverlay_Params.prototype.initDefaults_ = function() {
    this.overlay = new bindings.InterfaceRequest();
  };
  XRCompositorHost_CreateImmersiveOverlay_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRCompositorHost_CreateImmersiveOverlay_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCompositorHost_CreateImmersiveOverlay_Params.overlay
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRCompositorHost_CreateImmersiveOverlay_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRCompositorHost_CreateImmersiveOverlay_Params.decode = function(decoder) {
    var packed;
    var val = new XRCompositorHost_CreateImmersiveOverlay_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.overlay = decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRCompositorHost_CreateImmersiveOverlay_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRCompositorHost_CreateImmersiveOverlay_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.overlay);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.prototype.initDefaults_ = function() {
    this.runtime = new XRRuntimePtr();
    this.gamepadFactory = new IsolatedXRGamepadProviderFactoryPtr();
    this.compositorHost = new XRCompositorHostPtr();
    this.deviceId = 0;
  };
  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.runtime
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.gamepadFactory
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 8, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.compositorHost
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.deviceId
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 24, vr_service$.XRDeviceId);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.encodedSize = codec.kStructHeaderSize + 32;

  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.runtime = decoder.decodeStruct(new codec.Interface(XRRuntimePtr));
    val.gamepadFactory = decoder.decodeStruct(new codec.Interface(IsolatedXRGamepadProviderFactoryPtr));
    val.compositorHost = decoder.decodeStruct(new codec.Interface(XRCompositorHostPtr));
    val.deviceId = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(XRRuntimePtr), val.runtime);
    encoder.encodeStruct(new codec.Interface(IsolatedXRGamepadProviderFactoryPtr), val.gamepadFactory);
    encoder.encodeStruct(new codec.Interface(XRCompositorHostPtr), val.compositorHost);
    encoder.encodeStruct(codec.Int32, val.deviceId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.prototype.initDefaults_ = function() {
    this.deviceIndex = 0;
  };
  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.deviceIndex
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, vr_service$.XRDeviceId);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.encodedSize = codec.kStructHeaderSize + 8;

  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.deviceIndex = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.deviceIndex);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.prototype.initDefaults_ = function() {
  };
  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.encodedSize = codec.kStructHeaderSize + 0;

  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function IsolatedXRRuntimeProvider_RequestDevices_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IsolatedXRRuntimeProvider_RequestDevices_Params.prototype.initDefaults_ = function() {
    this.client = new IsolatedXRRuntimeProviderClientPtr();
  };
  IsolatedXRRuntimeProvider_RequestDevices_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IsolatedXRRuntimeProvider_RequestDevices_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate IsolatedXRRuntimeProvider_RequestDevices_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IsolatedXRRuntimeProvider_RequestDevices_Params.encodedSize = codec.kStructHeaderSize + 8;

  IsolatedXRRuntimeProvider_RequestDevices_Params.decode = function(decoder) {
    var packed;
    var val = new IsolatedXRRuntimeProvider_RequestDevices_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.client = decoder.decodeStruct(new codec.Interface(IsolatedXRRuntimeProviderClientPtr));
    return val;
  };

  IsolatedXRRuntimeProvider_RequestDevices_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IsolatedXRRuntimeProvider_RequestDevices_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(IsolatedXRRuntimeProviderClientPtr), val.client);
  };
  function XRDeviceService_BindRuntimeProvider_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRDeviceService_BindRuntimeProvider_Params.prototype.initDefaults_ = function() {
    this.receiver = new bindings.InterfaceRequest();
  };
  XRDeviceService_BindRuntimeProvider_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRDeviceService_BindRuntimeProvider_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDeviceService_BindRuntimeProvider_Params.receiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRDeviceService_BindRuntimeProvider_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRDeviceService_BindRuntimeProvider_Params.decode = function(decoder) {
    var packed;
    var val = new XRDeviceService_BindRuntimeProvider_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver = decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRDeviceService_BindRuntimeProvider_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRDeviceService_BindRuntimeProvider_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.receiver);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRDeviceService_BindTestHook_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRDeviceService_BindTestHook_Params.prototype.initDefaults_ = function() {
    this.receiver = new bindings.InterfaceRequest();
  };
  XRDeviceService_BindTestHook_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRDeviceService_BindTestHook_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDeviceService_BindTestHook_Params.receiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRDeviceService_BindTestHook_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRDeviceService_BindTestHook_Params.decode = function(decoder) {
    var packed;
    var val = new XRDeviceService_BindTestHook_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver = decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRDeviceService_BindTestHook_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRDeviceService_BindTestHook_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.receiver);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  var kXRSessionController_SetFrameDataRestricted_Name = 0;

  function XRSessionControllerPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRSessionController,
                                                   handleOrPtrInfo);
  }

  function XRSessionControllerAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRSessionController, associatedInterfacePtrInfo);
  }

  XRSessionControllerAssociatedPtr.prototype =
      Object.create(XRSessionControllerPtr.prototype);
  XRSessionControllerAssociatedPtr.prototype.constructor =
      XRSessionControllerAssociatedPtr;

  function XRSessionControllerProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRSessionControllerPtr.prototype.setFrameDataRestricted = function() {
    return XRSessionControllerProxy.prototype.setFrameDataRestricted
        .apply(this.ptr.getProxy(), arguments);
  };

  XRSessionControllerProxy.prototype.setFrameDataRestricted = function(restricted) {
    var params_ = new XRSessionController_SetFrameDataRestricted_Params();
    params_.restricted = restricted;
    var builder = new codec.MessageV0Builder(
        kXRSessionController_SetFrameDataRestricted_Name,
        codec.align(XRSessionController_SetFrameDataRestricted_Params.encodedSize));
    builder.encodeStruct(XRSessionController_SetFrameDataRestricted_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRSessionControllerStub(delegate) {
    this.delegate_ = delegate;
  }
  XRSessionControllerStub.prototype.setFrameDataRestricted = function(restricted) {
    return this.delegate_ && this.delegate_.setFrameDataRestricted && this.delegate_.setFrameDataRestricted(restricted);
  }

  XRSessionControllerStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRSessionController_SetFrameDataRestricted_Name:
      var params = reader.decodeStruct(XRSessionController_SetFrameDataRestricted_Params);
      this.setFrameDataRestricted(params.restricted);
      return true;
    default:
      return false;
    }
  };

  XRSessionControllerStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRSessionControllerRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRSessionController_SetFrameDataRestricted_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRSessionController_SetFrameDataRestricted_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRSessionControllerResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRSessionController = {
    name: 'device.mojom.XRSessionController',
    kVersion: 0,
    ptrClass: XRSessionControllerPtr,
    proxyClass: XRSessionControllerProxy,
    stubClass: XRSessionControllerStub,
    validateRequest: validateXRSessionControllerRequest,
    validateResponse: null,
  };
  XRSessionControllerStub.prototype.validator = validateXRSessionControllerRequest;
  XRSessionControllerProxy.prototype.validator = null;
  var kXRRuntimeEventListener_OnDisplayInfoChanged_Name = 0;
  var kXRRuntimeEventListener_OnDeviceActivated_Name = 1;
  var kXRRuntimeEventListener_OnDeviceIdle_Name = 2;
  var kXRRuntimeEventListener_OnVisibilityStateChanged_Name = 3;
  var kXRRuntimeEventListener_OnExitPresent_Name = 4;

  function XRRuntimeEventListenerPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRRuntimeEventListener,
                                                   handleOrPtrInfo);
  }

  function XRRuntimeEventListenerAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRRuntimeEventListener, associatedInterfacePtrInfo);
  }

  XRRuntimeEventListenerAssociatedPtr.prototype =
      Object.create(XRRuntimeEventListenerPtr.prototype);
  XRRuntimeEventListenerAssociatedPtr.prototype.constructor =
      XRRuntimeEventListenerAssociatedPtr;

  function XRRuntimeEventListenerProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRRuntimeEventListenerPtr.prototype.onDisplayInfoChanged = function() {
    return XRRuntimeEventListenerProxy.prototype.onDisplayInfoChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeEventListenerProxy.prototype.onDisplayInfoChanged = function(displayInfo) {
    var params_ = new XRRuntimeEventListener_OnDisplayInfoChanged_Params();
    params_.displayInfo = displayInfo;
    var builder = new codec.MessageV0Builder(
        kXRRuntimeEventListener_OnDisplayInfoChanged_Name,
        codec.align(XRRuntimeEventListener_OnDisplayInfoChanged_Params.encodedSize));
    builder.encodeStruct(XRRuntimeEventListener_OnDisplayInfoChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRRuntimeEventListenerPtr.prototype.onDeviceActivated = function() {
    return XRRuntimeEventListenerProxy.prototype.onDeviceActivated
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeEventListenerProxy.prototype.onDeviceActivated = function(reason) {
    var params_ = new XRRuntimeEventListener_OnDeviceActivated_Params();
    params_.reason = reason;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRRuntimeEventListener_OnDeviceActivated_Name,
          codec.align(XRRuntimeEventListener_OnDeviceActivated_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRRuntimeEventListener_OnDeviceActivated_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRRuntimeEventListener_OnDeviceActivated_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRRuntimeEventListenerPtr.prototype.onDeviceIdle = function() {
    return XRRuntimeEventListenerProxy.prototype.onDeviceIdle
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeEventListenerProxy.prototype.onDeviceIdle = function(reason) {
    var params_ = new XRRuntimeEventListener_OnDeviceIdle_Params();
    params_.reason = reason;
    var builder = new codec.MessageV0Builder(
        kXRRuntimeEventListener_OnDeviceIdle_Name,
        codec.align(XRRuntimeEventListener_OnDeviceIdle_Params.encodedSize));
    builder.encodeStruct(XRRuntimeEventListener_OnDeviceIdle_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRRuntimeEventListenerPtr.prototype.onVisibilityStateChanged = function() {
    return XRRuntimeEventListenerProxy.prototype.onVisibilityStateChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeEventListenerProxy.prototype.onVisibilityStateChanged = function(visibilityState) {
    var params_ = new XRRuntimeEventListener_OnVisibilityStateChanged_Params();
    params_.visibilityState = visibilityState;
    var builder = new codec.MessageV0Builder(
        kXRRuntimeEventListener_OnVisibilityStateChanged_Name,
        codec.align(XRRuntimeEventListener_OnVisibilityStateChanged_Params.encodedSize));
    builder.encodeStruct(XRRuntimeEventListener_OnVisibilityStateChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRRuntimeEventListenerPtr.prototype.onExitPresent = function() {
    return XRRuntimeEventListenerProxy.prototype.onExitPresent
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeEventListenerProxy.prototype.onExitPresent = function() {
    var params_ = new XRRuntimeEventListener_OnExitPresent_Params();
    var builder = new codec.MessageV0Builder(
        kXRRuntimeEventListener_OnExitPresent_Name,
        codec.align(XRRuntimeEventListener_OnExitPresent_Params.encodedSize));
    builder.encodeStruct(XRRuntimeEventListener_OnExitPresent_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRRuntimeEventListenerStub(delegate) {
    this.delegate_ = delegate;
  }
  XRRuntimeEventListenerStub.prototype.onDisplayInfoChanged = function(displayInfo) {
    return this.delegate_ && this.delegate_.onDisplayInfoChanged && this.delegate_.onDisplayInfoChanged(displayInfo);
  }
  XRRuntimeEventListenerStub.prototype.onDeviceActivated = function(reason) {
    return this.delegate_ && this.delegate_.onDeviceActivated && this.delegate_.onDeviceActivated(reason);
  }
  XRRuntimeEventListenerStub.prototype.onDeviceIdle = function(reason) {
    return this.delegate_ && this.delegate_.onDeviceIdle && this.delegate_.onDeviceIdle(reason);
  }
  XRRuntimeEventListenerStub.prototype.onVisibilityStateChanged = function(visibilityState) {
    return this.delegate_ && this.delegate_.onVisibilityStateChanged && this.delegate_.onVisibilityStateChanged(visibilityState);
  }
  XRRuntimeEventListenerStub.prototype.onExitPresent = function() {
    return this.delegate_ && this.delegate_.onExitPresent && this.delegate_.onExitPresent();
  }

  XRRuntimeEventListenerStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRRuntimeEventListener_OnDisplayInfoChanged_Name:
      var params = reader.decodeStruct(XRRuntimeEventListener_OnDisplayInfoChanged_Params);
      this.onDisplayInfoChanged(params.displayInfo);
      return true;
    case kXRRuntimeEventListener_OnDeviceIdle_Name:
      var params = reader.decodeStruct(XRRuntimeEventListener_OnDeviceIdle_Params);
      this.onDeviceIdle(params.reason);
      return true;
    case kXRRuntimeEventListener_OnVisibilityStateChanged_Name:
      var params = reader.decodeStruct(XRRuntimeEventListener_OnVisibilityStateChanged_Params);
      this.onVisibilityStateChanged(params.visibilityState);
      return true;
    case kXRRuntimeEventListener_OnExitPresent_Name:
      var params = reader.decodeStruct(XRRuntimeEventListener_OnExitPresent_Params);
      this.onExitPresent();
      return true;
    default:
      return false;
    }
  };

  XRRuntimeEventListenerStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRRuntimeEventListener_OnDeviceActivated_Name:
      var params = reader.decodeStruct(XRRuntimeEventListener_OnDeviceActivated_Params);
      this.onDeviceActivated(params.reason).then(function(response) {
        var responseParams =
            new XRRuntimeEventListener_OnDeviceActivated_ResponseParams();
        responseParams.willNotPresent = response.willNotPresent;
        var builder = new codec.MessageV1Builder(
            kXRRuntimeEventListener_OnDeviceActivated_Name,
            codec.align(XRRuntimeEventListener_OnDeviceActivated_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRRuntimeEventListener_OnDeviceActivated_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXRRuntimeEventListenerRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRRuntimeEventListener_OnDisplayInfoChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntimeEventListener_OnDisplayInfoChanged_Params;
      break;
      case kXRRuntimeEventListener_OnDeviceActivated_Name:
        if (message.expectsResponse())
          paramsClass = XRRuntimeEventListener_OnDeviceActivated_Params;
      break;
      case kXRRuntimeEventListener_OnDeviceIdle_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntimeEventListener_OnDeviceIdle_Params;
      break;
      case kXRRuntimeEventListener_OnVisibilityStateChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntimeEventListener_OnVisibilityStateChanged_Params;
      break;
      case kXRRuntimeEventListener_OnExitPresent_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntimeEventListener_OnExitPresent_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRRuntimeEventListenerResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXRRuntimeEventListener_OnDeviceActivated_Name:
        if (message.isResponse())
          paramsClass = XRRuntimeEventListener_OnDeviceActivated_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XRRuntimeEventListener = {
    name: 'device.mojom.XRRuntimeEventListener',
    kVersion: 0,
    ptrClass: XRRuntimeEventListenerPtr,
    proxyClass: XRRuntimeEventListenerProxy,
    stubClass: XRRuntimeEventListenerStub,
    validateRequest: validateXRRuntimeEventListenerRequest,
    validateResponse: validateXRRuntimeEventListenerResponse,
  };
  XRRuntimeEventListenerStub.prototype.validator = validateXRRuntimeEventListenerRequest;
  XRRuntimeEventListenerProxy.prototype.validator = validateXRRuntimeEventListenerResponse;
  var kXRRuntime_RequestSession_Name = 0;
  var kXRRuntime_ListenToDeviceChanges_Name = 1;
  var kXRRuntime_EnsureInitialized_Name = 2;
  var kXRRuntime_SetListeningForActivate_Name = 3;
  var kXRRuntime_SetInlinePosesEnabled_Name = 4;

  function XRRuntimePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRRuntime,
                                                   handleOrPtrInfo);
  }

  function XRRuntimeAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRRuntime, associatedInterfacePtrInfo);
  }

  XRRuntimeAssociatedPtr.prototype =
      Object.create(XRRuntimePtr.prototype);
  XRRuntimeAssociatedPtr.prototype.constructor =
      XRRuntimeAssociatedPtr;

  function XRRuntimeProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRRuntimePtr.prototype.requestSession = function() {
    return XRRuntimeProxy.prototype.requestSession
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeProxy.prototype.requestSession = function(options) {
    var params_ = new XRRuntime_RequestSession_Params();
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRRuntime_RequestSession_Name,
          codec.align(XRRuntime_RequestSession_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRRuntime_RequestSession_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRRuntime_RequestSession_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRRuntimePtr.prototype.listenToDeviceChanges = function() {
    return XRRuntimeProxy.prototype.listenToDeviceChanges
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeProxy.prototype.listenToDeviceChanges = function(listener) {
    var params_ = new XRRuntime_ListenToDeviceChanges_Params();
    params_.listener = listener;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV2Builder(
          kXRRuntime_ListenToDeviceChanges_Name,
          codec.align(XRRuntime_ListenToDeviceChanges_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.setPayload(XRRuntime_ListenToDeviceChanges_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRRuntime_ListenToDeviceChanges_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRRuntimePtr.prototype.ensureInitialized = function() {
    return XRRuntimeProxy.prototype.ensureInitialized
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeProxy.prototype.ensureInitialized = function() {
    var params_ = new XRRuntime_EnsureInitialized_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRRuntime_EnsureInitialized_Name,
          codec.align(XRRuntime_EnsureInitialized_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRRuntime_EnsureInitialized_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRRuntime_EnsureInitialized_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRRuntimePtr.prototype.setListeningForActivate = function() {
    return XRRuntimeProxy.prototype.setListeningForActivate
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeProxy.prototype.setListeningForActivate = function(listenForActivation) {
    var params_ = new XRRuntime_SetListeningForActivate_Params();
    params_.listenForActivation = listenForActivation;
    var builder = new codec.MessageV0Builder(
        kXRRuntime_SetListeningForActivate_Name,
        codec.align(XRRuntime_SetListeningForActivate_Params.encodedSize));
    builder.encodeStruct(XRRuntime_SetListeningForActivate_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRRuntimePtr.prototype.setInlinePosesEnabled = function() {
    return XRRuntimeProxy.prototype.setInlinePosesEnabled
        .apply(this.ptr.getProxy(), arguments);
  };

  XRRuntimeProxy.prototype.setInlinePosesEnabled = function(enable) {
    var params_ = new XRRuntime_SetInlinePosesEnabled_Params();
    params_.enable = enable;
    var builder = new codec.MessageV0Builder(
        kXRRuntime_SetInlinePosesEnabled_Name,
        codec.align(XRRuntime_SetInlinePosesEnabled_Params.encodedSize));
    builder.encodeStruct(XRRuntime_SetInlinePosesEnabled_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRRuntimeStub(delegate) {
    this.delegate_ = delegate;
  }
  XRRuntimeStub.prototype.requestSession = function(options) {
    return this.delegate_ && this.delegate_.requestSession && this.delegate_.requestSession(options);
  }
  XRRuntimeStub.prototype.listenToDeviceChanges = function(listener) {
    return this.delegate_ && this.delegate_.listenToDeviceChanges && this.delegate_.listenToDeviceChanges(listener);
  }
  XRRuntimeStub.prototype.ensureInitialized = function() {
    return this.delegate_ && this.delegate_.ensureInitialized && this.delegate_.ensureInitialized();
  }
  XRRuntimeStub.prototype.setListeningForActivate = function(listenForActivation) {
    return this.delegate_ && this.delegate_.setListeningForActivate && this.delegate_.setListeningForActivate(listenForActivation);
  }
  XRRuntimeStub.prototype.setInlinePosesEnabled = function(enable) {
    return this.delegate_ && this.delegate_.setInlinePosesEnabled && this.delegate_.setInlinePosesEnabled(enable);
  }

  XRRuntimeStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRRuntime_SetListeningForActivate_Name:
      var params = reader.decodeStruct(XRRuntime_SetListeningForActivate_Params);
      this.setListeningForActivate(params.listenForActivation);
      return true;
    case kXRRuntime_SetInlinePosesEnabled_Name:
      var params = reader.decodeStruct(XRRuntime_SetInlinePosesEnabled_Params);
      this.setInlinePosesEnabled(params.enable);
      return true;
    default:
      return false;
    }
  };

  XRRuntimeStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRRuntime_RequestSession_Name:
      var params = reader.decodeStruct(XRRuntime_RequestSession_Params);
      this.requestSession(params.options).then(function(response) {
        var responseParams =
            new XRRuntime_RequestSession_ResponseParams();
        responseParams.session = response.session;
        responseParams.controller = response.controller;
        var builder = new codec.MessageV1Builder(
            kXRRuntime_RequestSession_Name,
            codec.align(XRRuntime_RequestSession_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRRuntime_RequestSession_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRRuntime_ListenToDeviceChanges_Name:
      var params = reader.decodeStruct(XRRuntime_ListenToDeviceChanges_Params);
      this.listenToDeviceChanges(params.listener).then(function(response) {
        var responseParams =
            new XRRuntime_ListenToDeviceChanges_ResponseParams();
        responseParams.displayInfo = response.displayInfo;
        var builder = new codec.MessageV2Builder(
            kXRRuntime_ListenToDeviceChanges_Name,
            codec.align(XRRuntime_ListenToDeviceChanges_ResponseParams
                .encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.setPayload(XRRuntime_ListenToDeviceChanges_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRRuntime_EnsureInitialized_Name:
      var params = reader.decodeStruct(XRRuntime_EnsureInitialized_Params);
      this.ensureInitialized().then(function(response) {
        var responseParams =
            new XRRuntime_EnsureInitialized_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kXRRuntime_EnsureInitialized_Name,
            codec.align(XRRuntime_EnsureInitialized_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRRuntime_EnsureInitialized_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXRRuntimeRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRRuntime_RequestSession_Name:
        if (message.expectsResponse())
          paramsClass = XRRuntime_RequestSession_Params;
      break;
      case kXRRuntime_ListenToDeviceChanges_Name:
        if (message.expectsResponse())
          paramsClass = XRRuntime_ListenToDeviceChanges_Params;
      break;
      case kXRRuntime_EnsureInitialized_Name:
        if (message.expectsResponse())
          paramsClass = XRRuntime_EnsureInitialized_Params;
      break;
      case kXRRuntime_SetListeningForActivate_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntime_SetListeningForActivate_Params;
      break;
      case kXRRuntime_SetInlinePosesEnabled_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRRuntime_SetInlinePosesEnabled_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRRuntimeResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXRRuntime_RequestSession_Name:
        if (message.isResponse())
          paramsClass = XRRuntime_RequestSession_ResponseParams;
        break;
      case kXRRuntime_ListenToDeviceChanges_Name:
        if (message.isResponse())
          paramsClass = XRRuntime_ListenToDeviceChanges_ResponseParams;
        break;
      case kXRRuntime_EnsureInitialized_Name:
        if (message.isResponse())
          paramsClass = XRRuntime_EnsureInitialized_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XRRuntime = {
    name: 'device.mojom.XRRuntime',
    kVersion: 0,
    ptrClass: XRRuntimePtr,
    proxyClass: XRRuntimeProxy,
    stubClass: XRRuntimeStub,
    validateRequest: validateXRRuntimeRequest,
    validateResponse: validateXRRuntimeResponse,
  };
  XRRuntimeStub.prototype.validator = validateXRRuntimeRequest;
  XRRuntimeProxy.prototype.validator = validateXRRuntimeResponse;
  var kIsolatedXRGamepadProvider_RequestUpdate_Name = 0;

  function IsolatedXRGamepadProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IsolatedXRGamepadProvider,
                                                   handleOrPtrInfo);
  }

  function IsolatedXRGamepadProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IsolatedXRGamepadProvider, associatedInterfacePtrInfo);
  }

  IsolatedXRGamepadProviderAssociatedPtr.prototype =
      Object.create(IsolatedXRGamepadProviderPtr.prototype);
  IsolatedXRGamepadProviderAssociatedPtr.prototype.constructor =
      IsolatedXRGamepadProviderAssociatedPtr;

  function IsolatedXRGamepadProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  IsolatedXRGamepadProviderPtr.prototype.requestUpdate = function() {
    return IsolatedXRGamepadProviderProxy.prototype.requestUpdate
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRGamepadProviderProxy.prototype.requestUpdate = function() {
    var params_ = new IsolatedXRGamepadProvider_RequestUpdate_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kIsolatedXRGamepadProvider_RequestUpdate_Name,
          codec.align(IsolatedXRGamepadProvider_RequestUpdate_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(IsolatedXRGamepadProvider_RequestUpdate_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(IsolatedXRGamepadProvider_RequestUpdate_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function IsolatedXRGamepadProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  IsolatedXRGamepadProviderStub.prototype.requestUpdate = function() {
    return this.delegate_ && this.delegate_.requestUpdate && this.delegate_.requestUpdate();
  }

  IsolatedXRGamepadProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  IsolatedXRGamepadProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIsolatedXRGamepadProvider_RequestUpdate_Name:
      var params = reader.decodeStruct(IsolatedXRGamepadProvider_RequestUpdate_Params);
      this.requestUpdate().then(function(response) {
        var responseParams =
            new IsolatedXRGamepadProvider_RequestUpdate_ResponseParams();
        responseParams.data = response.data;
        var builder = new codec.MessageV1Builder(
            kIsolatedXRGamepadProvider_RequestUpdate_Name,
            codec.align(IsolatedXRGamepadProvider_RequestUpdate_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(IsolatedXRGamepadProvider_RequestUpdate_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateIsolatedXRGamepadProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIsolatedXRGamepadProvider_RequestUpdate_Name:
        if (message.expectsResponse())
          paramsClass = IsolatedXRGamepadProvider_RequestUpdate_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIsolatedXRGamepadProviderResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kIsolatedXRGamepadProvider_RequestUpdate_Name:
        if (message.isResponse())
          paramsClass = IsolatedXRGamepadProvider_RequestUpdate_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var IsolatedXRGamepadProvider = {
    name: 'device.mojom.IsolatedXRGamepadProvider',
    kVersion: 0,
    ptrClass: IsolatedXRGamepadProviderPtr,
    proxyClass: IsolatedXRGamepadProviderProxy,
    stubClass: IsolatedXRGamepadProviderStub,
    validateRequest: validateIsolatedXRGamepadProviderRequest,
    validateResponse: validateIsolatedXRGamepadProviderResponse,
  };
  IsolatedXRGamepadProviderStub.prototype.validator = validateIsolatedXRGamepadProviderRequest;
  IsolatedXRGamepadProviderProxy.prototype.validator = validateIsolatedXRGamepadProviderResponse;
  var kIsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Name = 0;

  function IsolatedXRGamepadProviderFactoryPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IsolatedXRGamepadProviderFactory,
                                                   handleOrPtrInfo);
  }

  function IsolatedXRGamepadProviderFactoryAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IsolatedXRGamepadProviderFactory, associatedInterfacePtrInfo);
  }

  IsolatedXRGamepadProviderFactoryAssociatedPtr.prototype =
      Object.create(IsolatedXRGamepadProviderFactoryPtr.prototype);
  IsolatedXRGamepadProviderFactoryAssociatedPtr.prototype.constructor =
      IsolatedXRGamepadProviderFactoryAssociatedPtr;

  function IsolatedXRGamepadProviderFactoryProxy(receiver) {
    this.receiver_ = receiver;
  }
  IsolatedXRGamepadProviderFactoryPtr.prototype.getIsolatedXRGamepadProvider = function() {
    return IsolatedXRGamepadProviderFactoryProxy.prototype.getIsolatedXRGamepadProvider
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRGamepadProviderFactoryProxy.prototype.getIsolatedXRGamepadProvider = function(provider) {
    var params_ = new IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params();
    params_.provider = provider;
    var builder = new codec.MessageV0Builder(
        kIsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Name,
        codec.align(IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params.encodedSize));
    builder.encodeStruct(IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function IsolatedXRGamepadProviderFactoryStub(delegate) {
    this.delegate_ = delegate;
  }
  IsolatedXRGamepadProviderFactoryStub.prototype.getIsolatedXRGamepadProvider = function(provider) {
    return this.delegate_ && this.delegate_.getIsolatedXRGamepadProvider && this.delegate_.getIsolatedXRGamepadProvider(provider);
  }

  IsolatedXRGamepadProviderFactoryStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Name:
      var params = reader.decodeStruct(IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params);
      this.getIsolatedXRGamepadProvider(params.provider);
      return true;
    default:
      return false;
    }
  };

  IsolatedXRGamepadProviderFactoryStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateIsolatedXRGamepadProviderFactoryRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IsolatedXRGamepadProviderFactory_GetIsolatedXRGamepadProvider_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIsolatedXRGamepadProviderFactoryResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var IsolatedXRGamepadProviderFactory = {
    name: 'device.mojom.IsolatedXRGamepadProviderFactory',
    kVersion: 0,
    ptrClass: IsolatedXRGamepadProviderFactoryPtr,
    proxyClass: IsolatedXRGamepadProviderFactoryProxy,
    stubClass: IsolatedXRGamepadProviderFactoryStub,
    validateRequest: validateIsolatedXRGamepadProviderFactoryRequest,
    validateResponse: null,
  };
  IsolatedXRGamepadProviderFactoryStub.prototype.validator = validateIsolatedXRGamepadProviderFactoryRequest;
  IsolatedXRGamepadProviderFactoryProxy.prototype.validator = null;
  var kImmersiveOverlay_RequestNextOverlayPose_Name = 0;
  var kImmersiveOverlay_SubmitOverlayTexture_Name = 1;
  var kImmersiveOverlay_SetOverlayAndWebXRVisibility_Name = 2;
  var kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name = 3;

  function ImmersiveOverlayPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(ImmersiveOverlay,
                                                   handleOrPtrInfo);
  }

  function ImmersiveOverlayAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        ImmersiveOverlay, associatedInterfacePtrInfo);
  }

  ImmersiveOverlayAssociatedPtr.prototype =
      Object.create(ImmersiveOverlayPtr.prototype);
  ImmersiveOverlayAssociatedPtr.prototype.constructor =
      ImmersiveOverlayAssociatedPtr;

  function ImmersiveOverlayProxy(receiver) {
    this.receiver_ = receiver;
  }
  ImmersiveOverlayPtr.prototype.requestNextOverlayPose = function() {
    return ImmersiveOverlayProxy.prototype.requestNextOverlayPose
        .apply(this.ptr.getProxy(), arguments);
  };

  ImmersiveOverlayProxy.prototype.requestNextOverlayPose = function() {
    var params_ = new ImmersiveOverlay_RequestNextOverlayPose_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kImmersiveOverlay_RequestNextOverlayPose_Name,
          codec.align(ImmersiveOverlay_RequestNextOverlayPose_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(ImmersiveOverlay_RequestNextOverlayPose_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(ImmersiveOverlay_RequestNextOverlayPose_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ImmersiveOverlayPtr.prototype.submitOverlayTexture = function() {
    return ImmersiveOverlayProxy.prototype.submitOverlayTexture
        .apply(this.ptr.getProxy(), arguments);
  };

  ImmersiveOverlayProxy.prototype.submitOverlayTexture = function(frameId, texture, leftBounds, rightBounds) {
    var params_ = new ImmersiveOverlay_SubmitOverlayTexture_Params();
    params_.frameId = frameId;
    params_.texture = texture;
    params_.leftBounds = leftBounds;
    params_.rightBounds = rightBounds;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kImmersiveOverlay_SubmitOverlayTexture_Name,
          codec.align(ImmersiveOverlay_SubmitOverlayTexture_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(ImmersiveOverlay_SubmitOverlayTexture_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(ImmersiveOverlay_SubmitOverlayTexture_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  ImmersiveOverlayPtr.prototype.setOverlayAndWebXRVisibility = function() {
    return ImmersiveOverlayProxy.prototype.setOverlayAndWebXRVisibility
        .apply(this.ptr.getProxy(), arguments);
  };

  ImmersiveOverlayProxy.prototype.setOverlayAndWebXRVisibility = function(overlayVisible, webxrVisible) {
    var params_ = new ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params();
    params_.overlayVisible = overlayVisible;
    params_.webxrVisible = webxrVisible;
    var builder = new codec.MessageV0Builder(
        kImmersiveOverlay_SetOverlayAndWebXRVisibility_Name,
        codec.align(ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params.encodedSize));
    builder.encodeStruct(ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ImmersiveOverlayPtr.prototype.requestNotificationOnWebXrSubmitted = function() {
    return ImmersiveOverlayProxy.prototype.requestNotificationOnWebXrSubmitted
        .apply(this.ptr.getProxy(), arguments);
  };

  ImmersiveOverlayProxy.prototype.requestNotificationOnWebXrSubmitted = function() {
    var params_ = new ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name,
          codec.align(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function ImmersiveOverlayStub(delegate) {
    this.delegate_ = delegate;
  }
  ImmersiveOverlayStub.prototype.requestNextOverlayPose = function() {
    return this.delegate_ && this.delegate_.requestNextOverlayPose && this.delegate_.requestNextOverlayPose();
  }
  ImmersiveOverlayStub.prototype.submitOverlayTexture = function(frameId, texture, leftBounds, rightBounds) {
    return this.delegate_ && this.delegate_.submitOverlayTexture && this.delegate_.submitOverlayTexture(frameId, texture, leftBounds, rightBounds);
  }
  ImmersiveOverlayStub.prototype.setOverlayAndWebXRVisibility = function(overlayVisible, webxrVisible) {
    return this.delegate_ && this.delegate_.setOverlayAndWebXRVisibility && this.delegate_.setOverlayAndWebXRVisibility(overlayVisible, webxrVisible);
  }
  ImmersiveOverlayStub.prototype.requestNotificationOnWebXrSubmitted = function() {
    return this.delegate_ && this.delegate_.requestNotificationOnWebXrSubmitted && this.delegate_.requestNotificationOnWebXrSubmitted();
  }

  ImmersiveOverlayStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kImmersiveOverlay_SetOverlayAndWebXRVisibility_Name:
      var params = reader.decodeStruct(ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params);
      this.setOverlayAndWebXRVisibility(params.overlayVisible, params.webxrVisible);
      return true;
    default:
      return false;
    }
  };

  ImmersiveOverlayStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kImmersiveOverlay_RequestNextOverlayPose_Name:
      var params = reader.decodeStruct(ImmersiveOverlay_RequestNextOverlayPose_Params);
      this.requestNextOverlayPose().then(function(response) {
        var responseParams =
            new ImmersiveOverlay_RequestNextOverlayPose_ResponseParams();
        responseParams.pose = response.pose;
        var builder = new codec.MessageV1Builder(
            kImmersiveOverlay_RequestNextOverlayPose_Name,
            codec.align(ImmersiveOverlay_RequestNextOverlayPose_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(ImmersiveOverlay_RequestNextOverlayPose_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kImmersiveOverlay_SubmitOverlayTexture_Name:
      var params = reader.decodeStruct(ImmersiveOverlay_SubmitOverlayTexture_Params);
      this.submitOverlayTexture(params.frameId, params.texture, params.leftBounds, params.rightBounds).then(function(response) {
        var responseParams =
            new ImmersiveOverlay_SubmitOverlayTexture_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kImmersiveOverlay_SubmitOverlayTexture_Name,
            codec.align(ImmersiveOverlay_SubmitOverlayTexture_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(ImmersiveOverlay_SubmitOverlayTexture_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name:
      var params = reader.decodeStruct(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params);
      this.requestNotificationOnWebXrSubmitted().then(function(response) {
        var responseParams =
            new ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name,
            codec.align(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateImmersiveOverlayRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kImmersiveOverlay_RequestNextOverlayPose_Name:
        if (message.expectsResponse())
          paramsClass = ImmersiveOverlay_RequestNextOverlayPose_Params;
      break;
      case kImmersiveOverlay_SubmitOverlayTexture_Name:
        if (message.expectsResponse())
          paramsClass = ImmersiveOverlay_SubmitOverlayTexture_Params;
      break;
      case kImmersiveOverlay_SetOverlayAndWebXRVisibility_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ImmersiveOverlay_SetOverlayAndWebXRVisibility_Params;
      break;
      case kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name:
        if (message.expectsResponse())
          paramsClass = ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateImmersiveOverlayResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kImmersiveOverlay_RequestNextOverlayPose_Name:
        if (message.isResponse())
          paramsClass = ImmersiveOverlay_RequestNextOverlayPose_ResponseParams;
        break;
      case kImmersiveOverlay_SubmitOverlayTexture_Name:
        if (message.isResponse())
          paramsClass = ImmersiveOverlay_SubmitOverlayTexture_ResponseParams;
        break;
      case kImmersiveOverlay_RequestNotificationOnWebXrSubmitted_Name:
        if (message.isResponse())
          paramsClass = ImmersiveOverlay_RequestNotificationOnWebXrSubmitted_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var ImmersiveOverlay = {
    name: 'device.mojom.ImmersiveOverlay',
    kVersion: 0,
    ptrClass: ImmersiveOverlayPtr,
    proxyClass: ImmersiveOverlayProxy,
    stubClass: ImmersiveOverlayStub,
    validateRequest: validateImmersiveOverlayRequest,
    validateResponse: validateImmersiveOverlayResponse,
  };
  ImmersiveOverlayStub.prototype.validator = validateImmersiveOverlayRequest;
  ImmersiveOverlayProxy.prototype.validator = validateImmersiveOverlayResponse;
  var kXRCompositorHost_CreateImmersiveOverlay_Name = 0;

  function XRCompositorHostPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRCompositorHost,
                                                   handleOrPtrInfo);
  }

  function XRCompositorHostAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRCompositorHost, associatedInterfacePtrInfo);
  }

  XRCompositorHostAssociatedPtr.prototype =
      Object.create(XRCompositorHostPtr.prototype);
  XRCompositorHostAssociatedPtr.prototype.constructor =
      XRCompositorHostAssociatedPtr;

  function XRCompositorHostProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRCompositorHostPtr.prototype.createImmersiveOverlay = function() {
    return XRCompositorHostProxy.prototype.createImmersiveOverlay
        .apply(this.ptr.getProxy(), arguments);
  };

  XRCompositorHostProxy.prototype.createImmersiveOverlay = function(overlay) {
    var params_ = new XRCompositorHost_CreateImmersiveOverlay_Params();
    params_.overlay = overlay;
    var builder = new codec.MessageV0Builder(
        kXRCompositorHost_CreateImmersiveOverlay_Name,
        codec.align(XRCompositorHost_CreateImmersiveOverlay_Params.encodedSize));
    builder.encodeStruct(XRCompositorHost_CreateImmersiveOverlay_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRCompositorHostStub(delegate) {
    this.delegate_ = delegate;
  }
  XRCompositorHostStub.prototype.createImmersiveOverlay = function(overlay) {
    return this.delegate_ && this.delegate_.createImmersiveOverlay && this.delegate_.createImmersiveOverlay(overlay);
  }

  XRCompositorHostStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRCompositorHost_CreateImmersiveOverlay_Name:
      var params = reader.decodeStruct(XRCompositorHost_CreateImmersiveOverlay_Params);
      this.createImmersiveOverlay(params.overlay);
      return true;
    default:
      return false;
    }
  };

  XRCompositorHostStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRCompositorHostRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRCompositorHost_CreateImmersiveOverlay_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRCompositorHost_CreateImmersiveOverlay_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRCompositorHostResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRCompositorHost = {
    name: 'device.mojom.XRCompositorHost',
    kVersion: 0,
    ptrClass: XRCompositorHostPtr,
    proxyClass: XRCompositorHostProxy,
    stubClass: XRCompositorHostStub,
    validateRequest: validateXRCompositorHostRequest,
    validateResponse: null,
  };
  XRCompositorHostStub.prototype.validator = validateXRCompositorHostRequest;
  XRCompositorHostProxy.prototype.validator = null;
  var kIsolatedXRRuntimeProviderClient_OnDeviceAdded_Name = 0;
  var kIsolatedXRRuntimeProviderClient_OnDeviceRemoved_Name = 1;
  var kIsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Name = 2;

  function IsolatedXRRuntimeProviderClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IsolatedXRRuntimeProviderClient,
                                                   handleOrPtrInfo);
  }

  function IsolatedXRRuntimeProviderClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IsolatedXRRuntimeProviderClient, associatedInterfacePtrInfo);
  }

  IsolatedXRRuntimeProviderClientAssociatedPtr.prototype =
      Object.create(IsolatedXRRuntimeProviderClientPtr.prototype);
  IsolatedXRRuntimeProviderClientAssociatedPtr.prototype.constructor =
      IsolatedXRRuntimeProviderClientAssociatedPtr;

  function IsolatedXRRuntimeProviderClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  IsolatedXRRuntimeProviderClientPtr.prototype.onDeviceAdded = function() {
    return IsolatedXRRuntimeProviderClientProxy.prototype.onDeviceAdded
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRRuntimeProviderClientProxy.prototype.onDeviceAdded = function(runtime, gamepadFactory, compositorHost, deviceId) {
    var params_ = new IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params();
    params_.runtime = runtime;
    params_.gamepadFactory = gamepadFactory;
    params_.compositorHost = compositorHost;
    params_.deviceId = deviceId;
    var builder = new codec.MessageV0Builder(
        kIsolatedXRRuntimeProviderClient_OnDeviceAdded_Name,
        codec.align(IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params.encodedSize));
    builder.encodeStruct(IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  IsolatedXRRuntimeProviderClientPtr.prototype.onDeviceRemoved = function() {
    return IsolatedXRRuntimeProviderClientProxy.prototype.onDeviceRemoved
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRRuntimeProviderClientProxy.prototype.onDeviceRemoved = function(deviceIndex) {
    var params_ = new IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params();
    params_.deviceIndex = deviceIndex;
    var builder = new codec.MessageV0Builder(
        kIsolatedXRRuntimeProviderClient_OnDeviceRemoved_Name,
        codec.align(IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params.encodedSize));
    builder.encodeStruct(IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  IsolatedXRRuntimeProviderClientPtr.prototype.onDevicesEnumerated = function() {
    return IsolatedXRRuntimeProviderClientProxy.prototype.onDevicesEnumerated
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRRuntimeProviderClientProxy.prototype.onDevicesEnumerated = function() {
    var params_ = new IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params();
    var builder = new codec.MessageV0Builder(
        kIsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Name,
        codec.align(IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params.encodedSize));
    builder.encodeStruct(IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function IsolatedXRRuntimeProviderClientStub(delegate) {
    this.delegate_ = delegate;
  }
  IsolatedXRRuntimeProviderClientStub.prototype.onDeviceAdded = function(runtime, gamepadFactory, compositorHost, deviceId) {
    return this.delegate_ && this.delegate_.onDeviceAdded && this.delegate_.onDeviceAdded(runtime, gamepadFactory, compositorHost, deviceId);
  }
  IsolatedXRRuntimeProviderClientStub.prototype.onDeviceRemoved = function(deviceIndex) {
    return this.delegate_ && this.delegate_.onDeviceRemoved && this.delegate_.onDeviceRemoved(deviceIndex);
  }
  IsolatedXRRuntimeProviderClientStub.prototype.onDevicesEnumerated = function() {
    return this.delegate_ && this.delegate_.onDevicesEnumerated && this.delegate_.onDevicesEnumerated();
  }

  IsolatedXRRuntimeProviderClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIsolatedXRRuntimeProviderClient_OnDeviceAdded_Name:
      var params = reader.decodeStruct(IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params);
      this.onDeviceAdded(params.runtime, params.gamepadFactory, params.compositorHost, params.deviceId);
      return true;
    case kIsolatedXRRuntimeProviderClient_OnDeviceRemoved_Name:
      var params = reader.decodeStruct(IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params);
      this.onDeviceRemoved(params.deviceIndex);
      return true;
    case kIsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Name:
      var params = reader.decodeStruct(IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params);
      this.onDevicesEnumerated();
      return true;
    default:
      return false;
    }
  };

  IsolatedXRRuntimeProviderClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateIsolatedXRRuntimeProviderClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIsolatedXRRuntimeProviderClient_OnDeviceAdded_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IsolatedXRRuntimeProviderClient_OnDeviceAdded_Params;
      break;
      case kIsolatedXRRuntimeProviderClient_OnDeviceRemoved_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IsolatedXRRuntimeProviderClient_OnDeviceRemoved_Params;
      break;
      case kIsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IsolatedXRRuntimeProviderClient_OnDevicesEnumerated_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIsolatedXRRuntimeProviderClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var IsolatedXRRuntimeProviderClient = {
    name: 'device.mojom.IsolatedXRRuntimeProviderClient',
    kVersion: 0,
    ptrClass: IsolatedXRRuntimeProviderClientPtr,
    proxyClass: IsolatedXRRuntimeProviderClientProxy,
    stubClass: IsolatedXRRuntimeProviderClientStub,
    validateRequest: validateIsolatedXRRuntimeProviderClientRequest,
    validateResponse: null,
  };
  IsolatedXRRuntimeProviderClientStub.prototype.validator = validateIsolatedXRRuntimeProviderClientRequest;
  IsolatedXRRuntimeProviderClientProxy.prototype.validator = null;
  var kIsolatedXRRuntimeProvider_RequestDevices_Name = 0;

  function IsolatedXRRuntimeProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(IsolatedXRRuntimeProvider,
                                                   handleOrPtrInfo);
  }

  function IsolatedXRRuntimeProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        IsolatedXRRuntimeProvider, associatedInterfacePtrInfo);
  }

  IsolatedXRRuntimeProviderAssociatedPtr.prototype =
      Object.create(IsolatedXRRuntimeProviderPtr.prototype);
  IsolatedXRRuntimeProviderAssociatedPtr.prototype.constructor =
      IsolatedXRRuntimeProviderAssociatedPtr;

  function IsolatedXRRuntimeProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  IsolatedXRRuntimeProviderPtr.prototype.requestDevices = function() {
    return IsolatedXRRuntimeProviderProxy.prototype.requestDevices
        .apply(this.ptr.getProxy(), arguments);
  };

  IsolatedXRRuntimeProviderProxy.prototype.requestDevices = function(client) {
    var params_ = new IsolatedXRRuntimeProvider_RequestDevices_Params();
    params_.client = client;
    var builder = new codec.MessageV0Builder(
        kIsolatedXRRuntimeProvider_RequestDevices_Name,
        codec.align(IsolatedXRRuntimeProvider_RequestDevices_Params.encodedSize));
    builder.encodeStruct(IsolatedXRRuntimeProvider_RequestDevices_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function IsolatedXRRuntimeProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  IsolatedXRRuntimeProviderStub.prototype.requestDevices = function(client) {
    return this.delegate_ && this.delegate_.requestDevices && this.delegate_.requestDevices(client);
  }

  IsolatedXRRuntimeProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kIsolatedXRRuntimeProvider_RequestDevices_Name:
      var params = reader.decodeStruct(IsolatedXRRuntimeProvider_RequestDevices_Params);
      this.requestDevices(params.client);
      return true;
    default:
      return false;
    }
  };

  IsolatedXRRuntimeProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateIsolatedXRRuntimeProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kIsolatedXRRuntimeProvider_RequestDevices_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = IsolatedXRRuntimeProvider_RequestDevices_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateIsolatedXRRuntimeProviderResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var IsolatedXRRuntimeProvider = {
    name: 'device.mojom.IsolatedXRRuntimeProvider',
    kVersion: 0,
    ptrClass: IsolatedXRRuntimeProviderPtr,
    proxyClass: IsolatedXRRuntimeProviderProxy,
    stubClass: IsolatedXRRuntimeProviderStub,
    validateRequest: validateIsolatedXRRuntimeProviderRequest,
    validateResponse: null,
  };
  IsolatedXRRuntimeProviderStub.prototype.validator = validateIsolatedXRRuntimeProviderRequest;
  IsolatedXRRuntimeProviderProxy.prototype.validator = null;
  var kXRDeviceService_BindRuntimeProvider_Name = 0;
  var kXRDeviceService_BindTestHook_Name = 1;

  function XRDeviceServicePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRDeviceService,
                                                   handleOrPtrInfo);
  }

  function XRDeviceServiceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRDeviceService, associatedInterfacePtrInfo);
  }

  XRDeviceServiceAssociatedPtr.prototype =
      Object.create(XRDeviceServicePtr.prototype);
  XRDeviceServiceAssociatedPtr.prototype.constructor =
      XRDeviceServiceAssociatedPtr;

  function XRDeviceServiceProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRDeviceServicePtr.prototype.bindRuntimeProvider = function() {
    return XRDeviceServiceProxy.prototype.bindRuntimeProvider
        .apply(this.ptr.getProxy(), arguments);
  };

  XRDeviceServiceProxy.prototype.bindRuntimeProvider = function(receiver) {
    var params_ = new XRDeviceService_BindRuntimeProvider_Params();
    params_.receiver = receiver;
    var builder = new codec.MessageV0Builder(
        kXRDeviceService_BindRuntimeProvider_Name,
        codec.align(XRDeviceService_BindRuntimeProvider_Params.encodedSize));
    builder.encodeStruct(XRDeviceService_BindRuntimeProvider_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRDeviceServicePtr.prototype.bindTestHook = function() {
    return XRDeviceServiceProxy.prototype.bindTestHook
        .apply(this.ptr.getProxy(), arguments);
  };

  XRDeviceServiceProxy.prototype.bindTestHook = function(receiver) {
    var params_ = new XRDeviceService_BindTestHook_Params();
    params_.receiver = receiver;
    var builder = new codec.MessageV0Builder(
        kXRDeviceService_BindTestHook_Name,
        codec.align(XRDeviceService_BindTestHook_Params.encodedSize));
    builder.encodeStruct(XRDeviceService_BindTestHook_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRDeviceServiceStub(delegate) {
    this.delegate_ = delegate;
  }
  XRDeviceServiceStub.prototype.bindRuntimeProvider = function(receiver) {
    return this.delegate_ && this.delegate_.bindRuntimeProvider && this.delegate_.bindRuntimeProvider(receiver);
  }
  XRDeviceServiceStub.prototype.bindTestHook = function(receiver) {
    return this.delegate_ && this.delegate_.bindTestHook && this.delegate_.bindTestHook(receiver);
  }

  XRDeviceServiceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRDeviceService_BindRuntimeProvider_Name:
      var params = reader.decodeStruct(XRDeviceService_BindRuntimeProvider_Params);
      this.bindRuntimeProvider(params.receiver);
      return true;
    case kXRDeviceService_BindTestHook_Name:
      var params = reader.decodeStruct(XRDeviceService_BindTestHook_Params);
      this.bindTestHook(params.receiver);
      return true;
    default:
      return false;
    }
  };

  XRDeviceServiceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRDeviceServiceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRDeviceService_BindRuntimeProvider_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRDeviceService_BindRuntimeProvider_Params;
      break;
      case kXRDeviceService_BindTestHook_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRDeviceService_BindTestHook_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRDeviceServiceResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRDeviceService = {
    name: 'device.mojom.XRDeviceService',
    kVersion: 0,
    ptrClass: XRDeviceServicePtr,
    proxyClass: XRDeviceServiceProxy,
    stubClass: XRDeviceServiceStub,
    validateRequest: validateXRDeviceServiceRequest,
    validateResponse: null,
  };
  XRDeviceServiceStub.prototype.validator = validateXRDeviceServiceRequest;
  XRDeviceServiceProxy.prototype.validator = null;
  exports.XRRuntimeSessionOptions = XRRuntimeSessionOptions;
  exports.XRGamepadButton = XRGamepadButton;
  exports.XRGamepad = XRGamepad;
  exports.XRGamepadData = XRGamepadData;
  exports.XRSessionController = XRSessionController;
  exports.XRSessionControllerPtr = XRSessionControllerPtr;
  exports.XRSessionControllerAssociatedPtr = XRSessionControllerAssociatedPtr;
  exports.XRRuntimeEventListener = XRRuntimeEventListener;
  exports.XRRuntimeEventListenerPtr = XRRuntimeEventListenerPtr;
  exports.XRRuntimeEventListenerAssociatedPtr = XRRuntimeEventListenerAssociatedPtr;
  exports.XRRuntime = XRRuntime;
  exports.XRRuntimePtr = XRRuntimePtr;
  exports.XRRuntimeAssociatedPtr = XRRuntimeAssociatedPtr;
  exports.IsolatedXRGamepadProvider = IsolatedXRGamepadProvider;
  exports.IsolatedXRGamepadProviderPtr = IsolatedXRGamepadProviderPtr;
  exports.IsolatedXRGamepadProviderAssociatedPtr = IsolatedXRGamepadProviderAssociatedPtr;
  exports.IsolatedXRGamepadProviderFactory = IsolatedXRGamepadProviderFactory;
  exports.IsolatedXRGamepadProviderFactoryPtr = IsolatedXRGamepadProviderFactoryPtr;
  exports.IsolatedXRGamepadProviderFactoryAssociatedPtr = IsolatedXRGamepadProviderFactoryAssociatedPtr;
  exports.ImmersiveOverlay = ImmersiveOverlay;
  exports.ImmersiveOverlayPtr = ImmersiveOverlayPtr;
  exports.ImmersiveOverlayAssociatedPtr = ImmersiveOverlayAssociatedPtr;
  exports.XRCompositorHost = XRCompositorHost;
  exports.XRCompositorHostPtr = XRCompositorHostPtr;
  exports.XRCompositorHostAssociatedPtr = XRCompositorHostAssociatedPtr;
  exports.IsolatedXRRuntimeProviderClient = IsolatedXRRuntimeProviderClient;
  exports.IsolatedXRRuntimeProviderClientPtr = IsolatedXRRuntimeProviderClientPtr;
  exports.IsolatedXRRuntimeProviderClientAssociatedPtr = IsolatedXRRuntimeProviderClientAssociatedPtr;
  exports.IsolatedXRRuntimeProvider = IsolatedXRRuntimeProvider;
  exports.IsolatedXRRuntimeProviderPtr = IsolatedXRRuntimeProviderPtr;
  exports.IsolatedXRRuntimeProviderAssociatedPtr = IsolatedXRRuntimeProviderAssociatedPtr;
  exports.XRDeviceService = XRDeviceService;
  exports.XRDeviceServicePtr = XRDeviceServicePtr;
  exports.XRDeviceServiceAssociatedPtr = XRDeviceServiceAssociatedPtr;
})();