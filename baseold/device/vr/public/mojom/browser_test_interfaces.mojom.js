// device/vr/public/mojom/browser_test_interfaces.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'device/vr/public/mojom/browser_test_interfaces.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('deviceTest.mojom');
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var transform$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/transform.mojom', '../../../../ui/gfx/mojom/transform.mojom.js');
  }


  var Eye = {};
  Eye.LEFT = 1;
  Eye.RIGHT = 2;
  Eye.MIN_VALUE = 1,
  Eye.MAX_VALUE = 2,

  Eye.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  Eye.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var TrackedDeviceClass = {};
  TrackedDeviceClass.kTrackedDeviceInvalid = 0;
  TrackedDeviceClass.kTrackedDeviceHmd = TrackedDeviceClass.kTrackedDeviceInvalid + 1;
  TrackedDeviceClass.kTrackedDeviceController = TrackedDeviceClass.kTrackedDeviceHmd + 1;
  TrackedDeviceClass.kTrackedDeviceGenericTracker = TrackedDeviceClass.kTrackedDeviceController + 1;
  TrackedDeviceClass.kTrackedDeviceTrackingReference = TrackedDeviceClass.kTrackedDeviceGenericTracker + 1;
  TrackedDeviceClass.kTrackedDeviceDisplayRedirect = TrackedDeviceClass.kTrackedDeviceTrackingReference + 1;
  TrackedDeviceClass.MIN_VALUE = 0,
  TrackedDeviceClass.MAX_VALUE = 5,

  TrackedDeviceClass.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    }
    return false;
  };

  TrackedDeviceClass.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ControllerRole = {};
  ControllerRole.kControllerRoleInvalid = 0;
  ControllerRole.kControllerRoleLeft = ControllerRole.kControllerRoleInvalid + 1;
  ControllerRole.kControllerRoleRight = ControllerRole.kControllerRoleLeft + 1;
  ControllerRole.kControllerRoleVoice = ControllerRole.kControllerRoleRight + 1;
  ControllerRole.MIN_VALUE = 0,
  ControllerRole.MAX_VALUE = 3,

  ControllerRole.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  ControllerRole.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function Color(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Color.prototype.initDefaults_ = function() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
  };
  Color.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Color.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  Color.encodedSize = codec.kStructHeaderSize + 8;

  Color.decode = function(decoder) {
    var packed;
    var val = new Color();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.r = decoder.decodeStruct(codec.Uint8);
    val.g = decoder.decodeStruct(codec.Uint8);
    val.b = decoder.decodeStruct(codec.Uint8);
    val.a = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Color.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Color.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint8, val.r);
    encoder.encodeStruct(codec.Uint8, val.g);
    encoder.encodeStruct(codec.Uint8, val.b);
    encoder.encodeStruct(codec.Uint8, val.a);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SubmittedFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SubmittedFrameData.prototype.initDefaults_ = function() {
    this.color = null;
    this.eye = 0;
    this.viewport = null;
    this.imageSize = null;
  };
  SubmittedFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SubmittedFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SubmittedFrameData.color
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Color, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SubmittedFrameData.eye
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, Eye);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SubmittedFrameData.viewport
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SubmittedFrameData.imageSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SubmittedFrameData.encodedSize = codec.kStructHeaderSize + 32;

  SubmittedFrameData.decode = function(decoder) {
    var packed;
    var val = new SubmittedFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.color = decoder.decodeStructPointer(Color);
    val.eye = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.viewport = decoder.decodeStructPointer(geometry$.Rect);
    val.imageSize = decoder.decodeStructPointer(geometry$.Size);
    return val;
  };

  SubmittedFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SubmittedFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Color, val.color);
    encoder.encodeStruct(codec.Int32, val.eye);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Rect, val.viewport);
    encoder.encodeStructPointer(geometry$.Size, val.imageSize);
  };
  function PoseFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PoseFrameData.prototype.initDefaults_ = function() {
    this.deviceToOrigin = null;
  };
  PoseFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PoseFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PoseFrameData.deviceToOrigin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, transform$.Transform, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PoseFrameData.encodedSize = codec.kStructHeaderSize + 8;

  PoseFrameData.decode = function(decoder) {
    var packed;
    var val = new PoseFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.deviceToOrigin = decoder.decodeStructPointer(transform$.Transform);
    return val;
  };

  PoseFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PoseFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(transform$.Transform, val.deviceToOrigin);
  };
  function ProjectionRaw(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ProjectionRaw.prototype.initDefaults_ = function() {
    this.left = 0;
    this.right = 0;
    this.top = 0;
    this.bottom = 0;
  };
  ProjectionRaw.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ProjectionRaw.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  ProjectionRaw.encodedSize = codec.kStructHeaderSize + 16;

  ProjectionRaw.decode = function(decoder) {
    var packed;
    var val = new ProjectionRaw();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.left = decoder.decodeStruct(codec.Float);
    val.right = decoder.decodeStruct(codec.Float);
    val.top = decoder.decodeStruct(codec.Float);
    val.bottom = decoder.decodeStruct(codec.Float);
    return val;
  };

  ProjectionRaw.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ProjectionRaw.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.left);
    encoder.encodeStruct(codec.Float, val.right);
    encoder.encodeStruct(codec.Float, val.top);
    encoder.encodeStruct(codec.Float, val.bottom);
  };
  function DeviceConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DeviceConfig.prototype.initDefaults_ = function() {
    this.interpupillaryDistance = 0;
    this.projectionLeft = null;
    this.projectionRight = null;
  };
  DeviceConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DeviceConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate DeviceConfig.projectionLeft
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, ProjectionRaw, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DeviceConfig.projectionRight
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, ProjectionRaw, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DeviceConfig.encodedSize = codec.kStructHeaderSize + 24;

  DeviceConfig.decode = function(decoder) {
    var packed;
    var val = new DeviceConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.interpupillaryDistance = decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.projectionLeft = decoder.decodeStructPointer(ProjectionRaw);
    val.projectionRight = decoder.decodeStructPointer(ProjectionRaw);
    return val;
  };

  DeviceConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DeviceConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.interpupillaryDistance);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(ProjectionRaw, val.projectionLeft);
    encoder.encodeStructPointer(ProjectionRaw, val.projectionRight);
  };
  function ControllerAxisData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ControllerAxisData.prototype.initDefaults_ = function() {
    this.x = 0;
    this.y = 0;
    this.axisType = 0;
  };
  ControllerAxisData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ControllerAxisData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  ControllerAxisData.encodedSize = codec.kStructHeaderSize + 16;

  ControllerAxisData.decode = function(decoder) {
    var packed;
    var val = new ControllerAxisData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x = decoder.decodeStruct(codec.Float);
    val.y = decoder.decodeStruct(codec.Float);
    val.axisType = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ControllerAxisData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ControllerAxisData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Uint8, val.axisType);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ControllerFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ControllerFrameData.prototype.initDefaults_ = function() {
    this.packetNumber = 0;
    this.role = ControllerRole.kControllerRoleInvalid;
    this.buttonsPressed = 0;
    this.buttonsTouched = 0;
    this.supportedButtons = 0;
    this.axisData = null;
    this.poseData = null;
    this.isValid = false;
  };
  ControllerFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ControllerFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;






    // validate ControllerFrameData.axisData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, new codec.PointerTo(ControllerAxisData), false, [5], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ControllerFrameData.poseData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, PoseFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ControllerFrameData.role
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, ControllerRole);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ControllerFrameData.encodedSize = codec.kStructHeaderSize + 56;

  ControllerFrameData.decode = function(decoder) {
    var packed;
    var val = new ControllerFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.packetNumber = decoder.decodeStruct(codec.Uint32);
    val.role = decoder.decodeStruct(codec.Int32);
    val.buttonsPressed = decoder.decodeStruct(codec.Uint64);
    val.buttonsTouched = decoder.decodeStruct(codec.Uint64);
    val.supportedButtons = decoder.decodeStruct(codec.Uint64);
    val.axisData = decoder.decodeArrayPointer(new codec.PointerTo(ControllerAxisData));
    val.poseData = decoder.decodeStructPointer(PoseFrameData);
    packed = decoder.readUint8();
    val.isValid = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ControllerFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ControllerFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.packetNumber);
    encoder.encodeStruct(codec.Int32, val.role);
    encoder.encodeStruct(codec.Uint64, val.buttonsPressed);
    encoder.encodeStruct(codec.Uint64, val.buttonsTouched);
    encoder.encodeStruct(codec.Uint64, val.supportedButtons);
    encoder.encodeArrayPointer(new codec.PointerTo(ControllerAxisData), val.axisData);
    encoder.encodeStructPointer(PoseFrameData, val.poseData);
    packed = 0;
    packed |= (val.isValid & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_OnFrameSubmitted_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_OnFrameSubmitted_Params.prototype.initDefaults_ = function() {
    this.frameData = null;
  };
  XRTestHook_OnFrameSubmitted_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_OnFrameSubmitted_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_OnFrameSubmitted_Params.frameData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, SubmittedFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_OnFrameSubmitted_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_OnFrameSubmitted_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_OnFrameSubmitted_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameData = decoder.decodeStructPointer(SubmittedFrameData);
    return val;
  };

  XRTestHook_OnFrameSubmitted_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_OnFrameSubmitted_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(SubmittedFrameData, val.frameData);
  };
  function XRTestHook_OnFrameSubmitted_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_OnFrameSubmitted_ResponseParams.prototype.initDefaults_ = function() {
  };
  XRTestHook_OnFrameSubmitted_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_OnFrameSubmitted_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_OnFrameSubmitted_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  XRTestHook_OnFrameSubmitted_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_OnFrameSubmitted_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRTestHook_OnFrameSubmitted_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_OnFrameSubmitted_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function XRTestHook_WaitGetDeviceConfig_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetDeviceConfig_Params.prototype.initDefaults_ = function() {
  };
  XRTestHook_WaitGetDeviceConfig_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetDeviceConfig_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetDeviceConfig_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRTestHook_WaitGetDeviceConfig_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetDeviceConfig_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRTestHook_WaitGetDeviceConfig_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetDeviceConfig_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRTestHook_WaitGetDeviceConfig_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetDeviceConfig_ResponseParams.prototype.initDefaults_ = function() {
    this.config = null;
  };
  XRTestHook_WaitGetDeviceConfig_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetDeviceConfig_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetDeviceConfig_ResponseParams.config
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, DeviceConfig, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetDeviceConfig_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetDeviceConfig_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetDeviceConfig_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.config = decoder.decodeStructPointer(DeviceConfig);
    return val;
  };

  XRTestHook_WaitGetDeviceConfig_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetDeviceConfig_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(DeviceConfig, val.config);
  };
  function XRTestHook_WaitGetPresentingPose_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetPresentingPose_Params.prototype.initDefaults_ = function() {
  };
  XRTestHook_WaitGetPresentingPose_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetPresentingPose_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetPresentingPose_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRTestHook_WaitGetPresentingPose_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetPresentingPose_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRTestHook_WaitGetPresentingPose_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetPresentingPose_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRTestHook_WaitGetPresentingPose_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetPresentingPose_ResponseParams.prototype.initDefaults_ = function() {
    this.data = null;
  };
  XRTestHook_WaitGetPresentingPose_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetPresentingPose_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetPresentingPose_ResponseParams.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, PoseFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetPresentingPose_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetPresentingPose_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetPresentingPose_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data = decoder.decodeStructPointer(PoseFrameData);
    return val;
  };

  XRTestHook_WaitGetPresentingPose_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetPresentingPose_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(PoseFrameData, val.data);
  };
  function XRTestHook_WaitGetMagicWindowPose_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetMagicWindowPose_Params.prototype.initDefaults_ = function() {
  };
  XRTestHook_WaitGetMagicWindowPose_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetMagicWindowPose_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetMagicWindowPose_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRTestHook_WaitGetMagicWindowPose_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetMagicWindowPose_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRTestHook_WaitGetMagicWindowPose_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetMagicWindowPose_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRTestHook_WaitGetMagicWindowPose_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetMagicWindowPose_ResponseParams.prototype.initDefaults_ = function() {
    this.data = null;
  };
  XRTestHook_WaitGetMagicWindowPose_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetMagicWindowPose_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetMagicWindowPose_ResponseParams.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, PoseFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetMagicWindowPose_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetMagicWindowPose_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetMagicWindowPose_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data = decoder.decodeStructPointer(PoseFrameData);
    return val;
  };

  XRTestHook_WaitGetMagicWindowPose_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetMagicWindowPose_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(PoseFrameData, val.data);
  };
  function XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.prototype.initDefaults_ = function() {
    this.index = 0;
  };
  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index = decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.prototype.initDefaults_ = function() {
    this.role = 0;
  };
  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.role
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, ControllerRole);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.role = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.role);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_WaitGetTrackedDeviceClass_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetTrackedDeviceClass_Params.prototype.initDefaults_ = function() {
    this.index = 0;
  };
  XRTestHook_WaitGetTrackedDeviceClass_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetTrackedDeviceClass_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetTrackedDeviceClass_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetTrackedDeviceClass_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetTrackedDeviceClass_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index = decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetTrackedDeviceClass_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetTrackedDeviceClass_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_WaitGetTrackedDeviceClass_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.prototype.initDefaults_ = function() {
    this.deviceClass = 0;
  };
  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.deviceClass
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, TrackedDeviceClass);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetTrackedDeviceClass_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.deviceClass = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.deviceClass);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_WaitGetControllerData_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetControllerData_Params.prototype.initDefaults_ = function() {
    this.index = 0;
  };
  XRTestHook_WaitGetControllerData_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetControllerData_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetControllerData_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetControllerData_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetControllerData_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index = decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetControllerData_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetControllerData_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTestHook_WaitGetControllerData_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetControllerData_ResponseParams.prototype.initDefaults_ = function() {
    this.data = null;
  };
  XRTestHook_WaitGetControllerData_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetControllerData_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTestHook_WaitGetControllerData_ResponseParams.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, ControllerFrameData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetControllerData_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetControllerData_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetControllerData_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data = decoder.decodeStructPointer(ControllerFrameData);
    return val;
  };

  XRTestHook_WaitGetControllerData_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetControllerData_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(ControllerFrameData, val.data);
  };
  function XRTestHook_WaitGetSessionStateStopping_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetSessionStateStopping_Params.prototype.initDefaults_ = function() {
  };
  XRTestHook_WaitGetSessionStateStopping_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetSessionStateStopping_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetSessionStateStopping_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRTestHook_WaitGetSessionStateStopping_Params.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetSessionStateStopping_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRTestHook_WaitGetSessionStateStopping_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetSessionStateStopping_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRTestHook_WaitGetSessionStateStopping_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTestHook_WaitGetSessionStateStopping_ResponseParams.prototype.initDefaults_ = function() {
    this.stopping = false;
  };
  XRTestHook_WaitGetSessionStateStopping_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTestHook_WaitGetSessionStateStopping_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRTestHook_WaitGetSessionStateStopping_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRTestHook_WaitGetSessionStateStopping_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRTestHook_WaitGetSessionStateStopping_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.stopping = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTestHook_WaitGetSessionStateStopping_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTestHook_WaitGetSessionStateStopping_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.stopping & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRServiceTestHook_SetTestHook_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRServiceTestHook_SetTestHook_Params.prototype.initDefaults_ = function() {
    this.hook = new XRTestHookPtr();
  };
  XRServiceTestHook_SetTestHook_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRServiceTestHook_SetTestHook_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRServiceTestHook_SetTestHook_Params.hook
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRServiceTestHook_SetTestHook_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRServiceTestHook_SetTestHook_Params.decode = function(decoder) {
    var packed;
    var val = new XRServiceTestHook_SetTestHook_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.hook = decoder.decodeStruct(new codec.NullableInterface(XRTestHookPtr));
    return val;
  };

  XRServiceTestHook_SetTestHook_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRServiceTestHook_SetTestHook_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.NullableInterface(XRTestHookPtr), val.hook);
  };
  function XRServiceTestHook_SetTestHook_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRServiceTestHook_SetTestHook_ResponseParams.prototype.initDefaults_ = function() {
  };
  XRServiceTestHook_SetTestHook_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRServiceTestHook_SetTestHook_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRServiceTestHook_SetTestHook_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  XRServiceTestHook_SetTestHook_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRServiceTestHook_SetTestHook_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRServiceTestHook_SetTestHook_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRServiceTestHook_SetTestHook_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.prototype.initDefaults_ = function() {
  };
  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.decode = function(decoder) {
    var packed;
    var val = new XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.prototype.initDefaults_ = function() {
  };
  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  var kXRTestHook_OnFrameSubmitted_Name = 0;
  var kXRTestHook_WaitGetDeviceConfig_Name = 1;
  var kXRTestHook_WaitGetPresentingPose_Name = 2;
  var kXRTestHook_WaitGetMagicWindowPose_Name = 3;
  var kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name = 4;
  var kXRTestHook_WaitGetTrackedDeviceClass_Name = 5;
  var kXRTestHook_WaitGetControllerData_Name = 6;
  var kXRTestHook_WaitGetSessionStateStopping_Name = 7;

  function XRTestHookPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRTestHook,
                                                   handleOrPtrInfo);
  }

  function XRTestHookAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRTestHook, associatedInterfacePtrInfo);
  }

  XRTestHookAssociatedPtr.prototype =
      Object.create(XRTestHookPtr.prototype);
  XRTestHookAssociatedPtr.prototype.constructor =
      XRTestHookAssociatedPtr;

  function XRTestHookProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRTestHookPtr.prototype.onFrameSubmitted = function() {
    return XRTestHookProxy.prototype.onFrameSubmitted
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.onFrameSubmitted = function(frameData) {
    var params_ = new XRTestHook_OnFrameSubmitted_Params();
    params_.frameData = frameData;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_OnFrameSubmitted_Name,
          codec.align(XRTestHook_OnFrameSubmitted_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_OnFrameSubmitted_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_OnFrameSubmitted_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetDeviceConfig = function() {
    return XRTestHookProxy.prototype.waitGetDeviceConfig
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetDeviceConfig = function() {
    var params_ = new XRTestHook_WaitGetDeviceConfig_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetDeviceConfig_Name,
          codec.align(XRTestHook_WaitGetDeviceConfig_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetDeviceConfig_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetDeviceConfig_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetPresentingPose = function() {
    return XRTestHookProxy.prototype.waitGetPresentingPose
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetPresentingPose = function() {
    var params_ = new XRTestHook_WaitGetPresentingPose_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetPresentingPose_Name,
          codec.align(XRTestHook_WaitGetPresentingPose_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetPresentingPose_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetPresentingPose_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetMagicWindowPose = function() {
    return XRTestHookProxy.prototype.waitGetMagicWindowPose
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetMagicWindowPose = function() {
    var params_ = new XRTestHook_WaitGetMagicWindowPose_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetMagicWindowPose_Name,
          codec.align(XRTestHook_WaitGetMagicWindowPose_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetMagicWindowPose_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetMagicWindowPose_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetControllerRoleForTrackedDeviceIndex = function() {
    return XRTestHookProxy.prototype.waitGetControllerRoleForTrackedDeviceIndex
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetControllerRoleForTrackedDeviceIndex = function(index) {
    var params_ = new XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params();
    params_.index = index;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name,
          codec.align(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetTrackedDeviceClass = function() {
    return XRTestHookProxy.prototype.waitGetTrackedDeviceClass
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetTrackedDeviceClass = function(index) {
    var params_ = new XRTestHook_WaitGetTrackedDeviceClass_Params();
    params_.index = index;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetTrackedDeviceClass_Name,
          codec.align(XRTestHook_WaitGetTrackedDeviceClass_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetTrackedDeviceClass_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetTrackedDeviceClass_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetControllerData = function() {
    return XRTestHookProxy.prototype.waitGetControllerData
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetControllerData = function(index) {
    var params_ = new XRTestHook_WaitGetControllerData_Params();
    params_.index = index;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetControllerData_Name,
          codec.align(XRTestHook_WaitGetControllerData_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetControllerData_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetControllerData_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRTestHookPtr.prototype.waitGetSessionStateStopping = function() {
    return XRTestHookProxy.prototype.waitGetSessionStateStopping
        .apply(this.ptr.getProxy(), arguments);
  };

  XRTestHookProxy.prototype.waitGetSessionStateStopping = function() {
    var params_ = new XRTestHook_WaitGetSessionStateStopping_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRTestHook_WaitGetSessionStateStopping_Name,
          codec.align(XRTestHook_WaitGetSessionStateStopping_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRTestHook_WaitGetSessionStateStopping_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRTestHook_WaitGetSessionStateStopping_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function XRTestHookStub(delegate) {
    this.delegate_ = delegate;
  }
  XRTestHookStub.prototype.onFrameSubmitted = function(frameData) {
    return this.delegate_ && this.delegate_.onFrameSubmitted && this.delegate_.onFrameSubmitted(frameData);
  }
  XRTestHookStub.prototype.waitGetDeviceConfig = function() {
    return this.delegate_ && this.delegate_.waitGetDeviceConfig && this.delegate_.waitGetDeviceConfig();
  }
  XRTestHookStub.prototype.waitGetPresentingPose = function() {
    return this.delegate_ && this.delegate_.waitGetPresentingPose && this.delegate_.waitGetPresentingPose();
  }
  XRTestHookStub.prototype.waitGetMagicWindowPose = function() {
    return this.delegate_ && this.delegate_.waitGetMagicWindowPose && this.delegate_.waitGetMagicWindowPose();
  }
  XRTestHookStub.prototype.waitGetControllerRoleForTrackedDeviceIndex = function(index) {
    return this.delegate_ && this.delegate_.waitGetControllerRoleForTrackedDeviceIndex && this.delegate_.waitGetControllerRoleForTrackedDeviceIndex(index);
  }
  XRTestHookStub.prototype.waitGetTrackedDeviceClass = function(index) {
    return this.delegate_ && this.delegate_.waitGetTrackedDeviceClass && this.delegate_.waitGetTrackedDeviceClass(index);
  }
  XRTestHookStub.prototype.waitGetControllerData = function(index) {
    return this.delegate_ && this.delegate_.waitGetControllerData && this.delegate_.waitGetControllerData(index);
  }
  XRTestHookStub.prototype.waitGetSessionStateStopping = function() {
    return this.delegate_ && this.delegate_.waitGetSessionStateStopping && this.delegate_.waitGetSessionStateStopping();
  }

  XRTestHookStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  XRTestHookStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRTestHook_OnFrameSubmitted_Name:
      var params = reader.decodeStruct(XRTestHook_OnFrameSubmitted_Params);
      this.onFrameSubmitted(params.frameData).then(function(response) {
        var responseParams =
            new XRTestHook_OnFrameSubmitted_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kXRTestHook_OnFrameSubmitted_Name,
            codec.align(XRTestHook_OnFrameSubmitted_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_OnFrameSubmitted_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetDeviceConfig_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetDeviceConfig_Params);
      this.waitGetDeviceConfig().then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetDeviceConfig_ResponseParams();
        responseParams.config = response.config;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetDeviceConfig_Name,
            codec.align(XRTestHook_WaitGetDeviceConfig_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetDeviceConfig_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetPresentingPose_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetPresentingPose_Params);
      this.waitGetPresentingPose().then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetPresentingPose_ResponseParams();
        responseParams.data = response.data;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetPresentingPose_Name,
            codec.align(XRTestHook_WaitGetPresentingPose_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetPresentingPose_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetMagicWindowPose_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetMagicWindowPose_Params);
      this.waitGetMagicWindowPose().then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetMagicWindowPose_ResponseParams();
        responseParams.data = response.data;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetMagicWindowPose_Name,
            codec.align(XRTestHook_WaitGetMagicWindowPose_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetMagicWindowPose_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params);
      this.waitGetControllerRoleForTrackedDeviceIndex(params.index).then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams();
        responseParams.role = response.role;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name,
            codec.align(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetTrackedDeviceClass_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetTrackedDeviceClass_Params);
      this.waitGetTrackedDeviceClass(params.index).then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetTrackedDeviceClass_ResponseParams();
        responseParams.deviceClass = response.deviceClass;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetTrackedDeviceClass_Name,
            codec.align(XRTestHook_WaitGetTrackedDeviceClass_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetTrackedDeviceClass_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetControllerData_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetControllerData_Params);
      this.waitGetControllerData(params.index).then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetControllerData_ResponseParams();
        responseParams.data = response.data;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetControllerData_Name,
            codec.align(XRTestHook_WaitGetControllerData_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetControllerData_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRTestHook_WaitGetSessionStateStopping_Name:
      var params = reader.decodeStruct(XRTestHook_WaitGetSessionStateStopping_Params);
      this.waitGetSessionStateStopping().then(function(response) {
        var responseParams =
            new XRTestHook_WaitGetSessionStateStopping_ResponseParams();
        responseParams.stopping = response.stopping;
        var builder = new codec.MessageV1Builder(
            kXRTestHook_WaitGetSessionStateStopping_Name,
            codec.align(XRTestHook_WaitGetSessionStateStopping_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRTestHook_WaitGetSessionStateStopping_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXRTestHookRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRTestHook_OnFrameSubmitted_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_OnFrameSubmitted_Params;
      break;
      case kXRTestHook_WaitGetDeviceConfig_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetDeviceConfig_Params;
      break;
      case kXRTestHook_WaitGetPresentingPose_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetPresentingPose_Params;
      break;
      case kXRTestHook_WaitGetMagicWindowPose_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetMagicWindowPose_Params;
      break;
      case kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Params;
      break;
      case kXRTestHook_WaitGetTrackedDeviceClass_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetTrackedDeviceClass_Params;
      break;
      case kXRTestHook_WaitGetControllerData_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetControllerData_Params;
      break;
      case kXRTestHook_WaitGetSessionStateStopping_Name:
        if (message.expectsResponse())
          paramsClass = XRTestHook_WaitGetSessionStateStopping_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRTestHookResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXRTestHook_OnFrameSubmitted_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_OnFrameSubmitted_ResponseParams;
        break;
      case kXRTestHook_WaitGetDeviceConfig_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetDeviceConfig_ResponseParams;
        break;
      case kXRTestHook_WaitGetPresentingPose_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetPresentingPose_ResponseParams;
        break;
      case kXRTestHook_WaitGetMagicWindowPose_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetMagicWindowPose_ResponseParams;
        break;
      case kXRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetControllerRoleForTrackedDeviceIndex_ResponseParams;
        break;
      case kXRTestHook_WaitGetTrackedDeviceClass_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetTrackedDeviceClass_ResponseParams;
        break;
      case kXRTestHook_WaitGetControllerData_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetControllerData_ResponseParams;
        break;
      case kXRTestHook_WaitGetSessionStateStopping_Name:
        if (message.isResponse())
          paramsClass = XRTestHook_WaitGetSessionStateStopping_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XRTestHook = {
    name: 'device_test.mojom.XRTestHook',
    kVersion: 0,
    ptrClass: XRTestHookPtr,
    proxyClass: XRTestHookProxy,
    stubClass: XRTestHookStub,
    validateRequest: validateXRTestHookRequest,
    validateResponse: validateXRTestHookResponse,
  };
  XRTestHookStub.prototype.validator = validateXRTestHookRequest;
  XRTestHookProxy.prototype.validator = validateXRTestHookResponse;
  var kXRServiceTestHook_SetTestHook_Name = 0;
  var kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name = 1;

  function XRServiceTestHookPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRServiceTestHook,
                                                   handleOrPtrInfo);
  }

  function XRServiceTestHookAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRServiceTestHook, associatedInterfacePtrInfo);
  }

  XRServiceTestHookAssociatedPtr.prototype =
      Object.create(XRServiceTestHookPtr.prototype);
  XRServiceTestHookAssociatedPtr.prototype.constructor =
      XRServiceTestHookAssociatedPtr;

  function XRServiceTestHookProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRServiceTestHookPtr.prototype.setTestHook = function() {
    return XRServiceTestHookProxy.prototype.setTestHook
        .apply(this.ptr.getProxy(), arguments);
  };

  XRServiceTestHookProxy.prototype.setTestHook = function(hook) {
    var params_ = new XRServiceTestHook_SetTestHook_Params();
    params_.hook = hook;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRServiceTestHook_SetTestHook_Name,
          codec.align(XRServiceTestHook_SetTestHook_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRServiceTestHook_SetTestHook_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRServiceTestHook_SetTestHook_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRServiceTestHookPtr.prototype.terminateDeviceServiceProcessForTesting = function() {
    return XRServiceTestHookProxy.prototype.terminateDeviceServiceProcessForTesting
        .apply(this.ptr.getProxy(), arguments);
  };

  XRServiceTestHookProxy.prototype.terminateDeviceServiceProcessForTesting = function() {
    var params_ = new XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name,
          codec.align(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function XRServiceTestHookStub(delegate) {
    this.delegate_ = delegate;
  }
  XRServiceTestHookStub.prototype.setTestHook = function(hook) {
    return this.delegate_ && this.delegate_.setTestHook && this.delegate_.setTestHook(hook);
  }
  XRServiceTestHookStub.prototype.terminateDeviceServiceProcessForTesting = function() {
    return this.delegate_ && this.delegate_.terminateDeviceServiceProcessForTesting && this.delegate_.terminateDeviceServiceProcessForTesting();
  }

  XRServiceTestHookStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  XRServiceTestHookStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRServiceTestHook_SetTestHook_Name:
      var params = reader.decodeStruct(XRServiceTestHook_SetTestHook_Params);
      this.setTestHook(params.hook).then(function(response) {
        var responseParams =
            new XRServiceTestHook_SetTestHook_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kXRServiceTestHook_SetTestHook_Name,
            codec.align(XRServiceTestHook_SetTestHook_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRServiceTestHook_SetTestHook_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name:
      var params = reader.decodeStruct(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params);
      this.terminateDeviceServiceProcessForTesting().then(function(response) {
        var responseParams =
            new XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name,
            codec.align(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXRServiceTestHookRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRServiceTestHook_SetTestHook_Name:
        if (message.expectsResponse())
          paramsClass = XRServiceTestHook_SetTestHook_Params;
      break;
      case kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name:
        if (message.expectsResponse())
          paramsClass = XRServiceTestHook_TerminateDeviceServiceProcessForTesting_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRServiceTestHookResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXRServiceTestHook_SetTestHook_Name:
        if (message.isResponse())
          paramsClass = XRServiceTestHook_SetTestHook_ResponseParams;
        break;
      case kXRServiceTestHook_TerminateDeviceServiceProcessForTesting_Name:
        if (message.isResponse())
          paramsClass = XRServiceTestHook_TerminateDeviceServiceProcessForTesting_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XRServiceTestHook = {
    name: 'device_test.mojom.XRServiceTestHook',
    kVersion: 0,
    ptrClass: XRServiceTestHookPtr,
    proxyClass: XRServiceTestHookProxy,
    stubClass: XRServiceTestHookStub,
    validateRequest: validateXRServiceTestHookRequest,
    validateResponse: validateXRServiceTestHookResponse,
  };
  XRServiceTestHookStub.prototype.validator = validateXRServiceTestHookRequest;
  XRServiceTestHookProxy.prototype.validator = validateXRServiceTestHookResponse;
  exports.Eye = Eye;
  exports.TrackedDeviceClass = TrackedDeviceClass;
  exports.ControllerRole = ControllerRole;
  exports.Color = Color;
  exports.SubmittedFrameData = SubmittedFrameData;
  exports.PoseFrameData = PoseFrameData;
  exports.ProjectionRaw = ProjectionRaw;
  exports.DeviceConfig = DeviceConfig;
  exports.ControllerAxisData = ControllerAxisData;
  exports.ControllerFrameData = ControllerFrameData;
  exports.XRTestHook = XRTestHook;
  exports.XRTestHookPtr = XRTestHookPtr;
  exports.XRTestHookAssociatedPtr = XRTestHookAssociatedPtr;
  exports.XRServiceTestHook = XRServiceTestHook;
  exports.XRServiceTestHookPtr = XRServiceTestHookPtr;
  exports.XRServiceTestHookAssociatedPtr = XRServiceTestHookAssociatedPtr;
})();