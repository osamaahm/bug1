// components/autofill/core/common/mojom/autofill_types.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/autofill/core/common/mojom/autofill_types.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('autofill.mojom');
  var text_direction$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/text_direction.mojom', '../../../../../mojo/public/mojom/base/text_direction.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../../../mojo/public/mojom/base/time.mojom.js');
  }
  var string16$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/string16.mojom', '../../../../../mojo/public/mojom/base/string16.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var origin$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/origin.mojom', '../../../../../url/mojom/origin.mojom.js');
  }
  var url$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/url.mojom', '../../../../../url/mojom/url.mojom.js');
  }


  var SubmissionIndicatorEvent = {};
  SubmissionIndicatorEvent.NONE = 0;
  SubmissionIndicatorEvent.HTML_FORM_SUBMISSION = 1;
  SubmissionIndicatorEvent.SAME_DOCUMENT_NAVIGATION = 2;
  SubmissionIndicatorEvent.XHR_SUCCEEDED = 3;
  SubmissionIndicatorEvent.FRAME_DETACHED = 4;
  SubmissionIndicatorEvent.DOM_MUTATION_AFTER_XHR = 6;
  SubmissionIndicatorEvent.PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD = 7;
  SubmissionIndicatorEvent.PROBABLE_FORM_SUBMISSION = 10;
  SubmissionIndicatorEvent.MIN_VALUE = 0,
  SubmissionIndicatorEvent.MAX_VALUE = 10,

  SubmissionIndicatorEvent.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 10:
      return true;
    }
    return false;
  };

  SubmissionIndicatorEvent.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var PasswordFormFieldPredictionType = {};
  PasswordFormFieldPredictionType.kUsername = 0;
  PasswordFormFieldPredictionType.kCurrentPassword = PasswordFormFieldPredictionType.kUsername + 1;
  PasswordFormFieldPredictionType.kNewPassword = PasswordFormFieldPredictionType.kCurrentPassword + 1;
  PasswordFormFieldPredictionType.kNotPassword = PasswordFormFieldPredictionType.kNewPassword + 1;
  PasswordFormFieldPredictionType.MIN_VALUE = 0,
  PasswordFormFieldPredictionType.MAX_VALUE = 3,

  PasswordFormFieldPredictionType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  PasswordFormFieldPredictionType.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SubmissionSource = {};
  SubmissionSource.NONE = 0;
  SubmissionSource.SAME_DOCUMENT_NAVIGATION = SubmissionSource.NONE + 1;
  SubmissionSource.XHR_SUCCEEDED = SubmissionSource.SAME_DOCUMENT_NAVIGATION + 1;
  SubmissionSource.FRAME_DETACHED = SubmissionSource.XHR_SUCCEEDED + 1;
  SubmissionSource.DOM_MUTATION_AFTER_XHR = SubmissionSource.FRAME_DETACHED + 1;
  SubmissionSource.PROBABLY_FORM_SUBMITTED = SubmissionSource.DOM_MUTATION_AFTER_XHR + 1;
  SubmissionSource.FORM_SUBMISSION = SubmissionSource.PROBABLY_FORM_SUBMITTED + 1;
  SubmissionSource.MIN_VALUE = 0,
  SubmissionSource.MAX_VALUE = 6,

  SubmissionSource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    }
    return false;
  };

  SubmissionSource.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var FocusedFieldType = {};
  FocusedFieldType.kUnknown = 0;
  FocusedFieldType.kUnfillableElement = FocusedFieldType.kUnknown + 1;
  FocusedFieldType.kFillableTextArea = FocusedFieldType.kUnfillableElement + 1;
  FocusedFieldType.kFillableSearchField = FocusedFieldType.kFillableTextArea + 1;
  FocusedFieldType.kFillableNonSearchField = FocusedFieldType.kFillableSearchField + 1;
  FocusedFieldType.kFillableUsernameField = FocusedFieldType.kFillableNonSearchField + 1;
  FocusedFieldType.kFillablePasswordField = FocusedFieldType.kFillableUsernameField + 1;
  FocusedFieldType.MIN_VALUE = 0,
  FocusedFieldType.MAX_VALUE = 6,

  FocusedFieldType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    }
    return false;
  };

  FocusedFieldType.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ButtonTitleType = {};
  ButtonTitleType.NONE = 0;
  ButtonTitleType.BUTTON_ELEMENT_SUBMIT_TYPE = 1;
  ButtonTitleType.BUTTON_ELEMENT_BUTTON_TYPE = 2;
  ButtonTitleType.INPUT_ELEMENT_SUBMIT_TYPE = 3;
  ButtonTitleType.INPUT_ELEMENT_BUTTON_TYPE = 4;
  ButtonTitleType.HYPERLINK = 5;
  ButtonTitleType.DIV = 6;
  ButtonTitleType.SPAN = 7;
  ButtonTitleType.MIN_VALUE = 0,
  ButtonTitleType.MAX_VALUE = 7,

  ButtonTitleType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    }
    return false;
  };

  ButtonTitleType.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AutofillState = {};
  AutofillState.kNoSuggestions = 0;
  AutofillState.kAutofillAvailable = AutofillState.kNoSuggestions + 1;
  AutofillState.kAutocompleteAvailable = AutofillState.kAutofillAvailable + 1;
  AutofillState.MIN_VALUE = 0,
  AutofillState.MAX_VALUE = 2,

  AutofillState.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  AutofillState.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function FormFieldData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  FormFieldData.CheckStatus = {};
  FormFieldData.CheckStatus.kNotCheckable = 0;
  FormFieldData.CheckStatus.kCheckableButUnchecked = FormFieldData.CheckStatus.kNotCheckable + 1;
  FormFieldData.CheckStatus.kChecked = FormFieldData.CheckStatus.kCheckableButUnchecked + 1;
  FormFieldData.CheckStatus.MIN_VALUE = 0,
  FormFieldData.CheckStatus.MAX_VALUE = 2,

  FormFieldData.CheckStatus.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  FormFieldData.CheckStatus.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  FormFieldData.RoleAttribute = {};
  FormFieldData.RoleAttribute.kPresentation = 0;
  FormFieldData.RoleAttribute.kOther = FormFieldData.RoleAttribute.kPresentation + 1;
  FormFieldData.RoleAttribute.MIN_VALUE = 0,
  FormFieldData.RoleAttribute.MAX_VALUE = 1,

  FormFieldData.RoleAttribute.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  FormFieldData.RoleAttribute.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  FormFieldData.LabelSource = {};
  FormFieldData.LabelSource.kUnknown = 0;
  FormFieldData.LabelSource.kLabelTag = FormFieldData.LabelSource.kUnknown + 1;
  FormFieldData.LabelSource.kPTag = FormFieldData.LabelSource.kLabelTag + 1;
  FormFieldData.LabelSource.kDivTable = FormFieldData.LabelSource.kPTag + 1;
  FormFieldData.LabelSource.kTdTag = FormFieldData.LabelSource.kDivTable + 1;
  FormFieldData.LabelSource.kDdTag = FormFieldData.LabelSource.kTdTag + 1;
  FormFieldData.LabelSource.kLiTag = FormFieldData.LabelSource.kDdTag + 1;
  FormFieldData.LabelSource.kPlaceHolder = FormFieldData.LabelSource.kLiTag + 1;
  FormFieldData.LabelSource.kAriaLabel = FormFieldData.LabelSource.kPlaceHolder + 1;
  FormFieldData.LabelSource.kCombined = FormFieldData.LabelSource.kAriaLabel + 1;
  FormFieldData.LabelSource.kValue = FormFieldData.LabelSource.kCombined + 1;
  FormFieldData.LabelSource.MIN_VALUE = 0,
  FormFieldData.LabelSource.MAX_VALUE = 10,

  FormFieldData.LabelSource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    }
    return false;
  };

  FormFieldData.LabelSource.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  FormFieldData.prototype.initDefaults_ = function() {
    this.label = null;
    this.name = null;
    this.idAttribute = null;
    this.nameAttribute = null;
    this.value = null;
    this.formControlType = null;
    this.autocompleteAttribute = null;
    this.placeholder = null;
    this.cssClasses = null;
    this.ariaLabel = null;
    this.ariaDescription = null;
    this.uniqueRendererId = 0;
    this.propertiesMask = 0;
    this.formControlAxId = 0;
    this.isAutofilled = false;
    this.isFocusable = false;
    this.shouldAutocomplete = false;
    this.isEnabled = false;
    this.isReadonly = false;
    this.maxLength = 0;
    this.section = null;
    this.checkStatus = 0;
    this.role = 0;
    this.textDirection = 0;
    this.labelSource = 0;
    this.typedValue = null;
    this.optionValues = null;
    this.optionContents = null;
  };
  FormFieldData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormFieldData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 168}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.label
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.name
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.idAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.nameAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.value
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.formControlType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 40, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.autocompleteAttribute
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.placeholder
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.cssClasses
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.ariaLabel
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.ariaDescription
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;







    // validate FormFieldData.section
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 112, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.checkStatus
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 120, FormFieldData.CheckStatus);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FormFieldData.role
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 124, FormFieldData.RoleAttribute);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.textDirection
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 128, text_direction$.TextDirection);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FormFieldData.typedValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 136, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.optionValues
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 144, 8, new codec.PointerTo(string16$.String16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.optionContents
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 152, 8, new codec.PointerTo(string16$.String16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.labelSource
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 132, FormFieldData.LabelSource);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FormFieldData.encodedSize = codec.kStructHeaderSize + 160;

  FormFieldData.decode = function(decoder) {
    var packed;
    var val = new FormFieldData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.label = decoder.decodeStructPointer(string16$.String16);
    val.name = decoder.decodeStructPointer(string16$.String16);
    val.idAttribute = decoder.decodeStructPointer(string16$.String16);
    val.nameAttribute = decoder.decodeStructPointer(string16$.String16);
    val.value = decoder.decodeStructPointer(string16$.String16);
    val.formControlType = decoder.decodeStruct(codec.String);
    val.autocompleteAttribute = decoder.decodeStruct(codec.String);
    val.placeholder = decoder.decodeStructPointer(string16$.String16);
    val.cssClasses = decoder.decodeStructPointer(string16$.String16);
    val.ariaLabel = decoder.decodeStructPointer(string16$.String16);
    val.ariaDescription = decoder.decodeStructPointer(string16$.String16);
    val.uniqueRendererId = decoder.decodeStruct(codec.Uint32);
    val.propertiesMask = decoder.decodeStruct(codec.Uint32);
    val.formControlAxId = decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isAutofilled = (packed >> 0) & 1 ? true : false;
    val.isFocusable = (packed >> 1) & 1 ? true : false;
    val.shouldAutocomplete = (packed >> 2) & 1 ? true : false;
    val.isEnabled = (packed >> 3) & 1 ? true : false;
    val.isReadonly = (packed >> 4) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.maxLength = decoder.decodeStruct(codec.Uint64);
    val.section = decoder.decodeStruct(codec.String);
    val.checkStatus = decoder.decodeStruct(codec.Int32);
    val.role = decoder.decodeStruct(codec.Int32);
    val.textDirection = decoder.decodeStruct(codec.Int32);
    val.labelSource = decoder.decodeStruct(codec.Int32);
    val.typedValue = decoder.decodeStructPointer(string16$.String16);
    val.optionValues = decoder.decodeArrayPointer(new codec.PointerTo(string16$.String16));
    val.optionContents = decoder.decodeArrayPointer(new codec.PointerTo(string16$.String16));
    return val;
  };

  FormFieldData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormFieldData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.label);
    encoder.encodeStructPointer(string16$.String16, val.name);
    encoder.encodeStructPointer(string16$.String16, val.idAttribute);
    encoder.encodeStructPointer(string16$.String16, val.nameAttribute);
    encoder.encodeStructPointer(string16$.String16, val.value);
    encoder.encodeStruct(codec.String, val.formControlType);
    encoder.encodeStruct(codec.String, val.autocompleteAttribute);
    encoder.encodeStructPointer(string16$.String16, val.placeholder);
    encoder.encodeStructPointer(string16$.String16, val.cssClasses);
    encoder.encodeStructPointer(string16$.String16, val.ariaLabel);
    encoder.encodeStructPointer(string16$.String16, val.ariaDescription);
    encoder.encodeStruct(codec.Uint32, val.uniqueRendererId);
    encoder.encodeStruct(codec.Uint32, val.propertiesMask);
    encoder.encodeStruct(codec.Int32, val.formControlAxId);
    packed = 0;
    packed |= (val.isAutofilled & 1) << 0
    packed |= (val.isFocusable & 1) << 1
    packed |= (val.shouldAutocomplete & 1) << 2
    packed |= (val.isEnabled & 1) << 3
    packed |= (val.isReadonly & 1) << 4
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.maxLength);
    encoder.encodeStruct(codec.String, val.section);
    encoder.encodeStruct(codec.Int32, val.checkStatus);
    encoder.encodeStruct(codec.Int32, val.role);
    encoder.encodeStruct(codec.Int32, val.textDirection);
    encoder.encodeStruct(codec.Int32, val.labelSource);
    encoder.encodeStructPointer(string16$.String16, val.typedValue);
    encoder.encodeArrayPointer(new codec.PointerTo(string16$.String16), val.optionValues);
    encoder.encodeArrayPointer(new codec.PointerTo(string16$.String16), val.optionContents);
  };
  function ButtonTitleInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ButtonTitleInfo.prototype.initDefaults_ = function() {
    this.title = null;
    this.type = 0;
  };
  ButtonTitleInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ButtonTitleInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ButtonTitleInfo.title
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ButtonTitleInfo.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, ButtonTitleType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ButtonTitleInfo.encodedSize = codec.kStructHeaderSize + 16;

  ButtonTitleInfo.decode = function(decoder) {
    var packed;
    var val = new ButtonTitleInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.title = decoder.decodeStructPointer(string16$.String16);
    val.type = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ButtonTitleInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ButtonTitleInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.title);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function FormData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormData.prototype.initDefaults_ = function() {
    this.idAttribute = null;
    this.nameAttribute = null;
    this.name = null;
    this.buttonTitles = null;
    this.url = null;
    this.action = null;
    this.isActionEmpty = false;
    this.isFormTag = false;
    this.isFormlessCheckout = false;
    this.isGaiaWithSkipSavePasswordForm = false;
    this.uniqueRendererId = 0;
    this.mainFrameOrigin = null;
    this.submissionEvent = 0;
    this.fields = null;
    this.usernamePredictions = null;
  };
  FormData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 96}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.idAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.nameAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.name
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.buttonTitles
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(ButtonTitleInfo), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.url
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.action
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate FormData.mainFrameOrigin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, origin$.Origin, false);
    if (err !== validator.validationError.NONE)
        return err;





    // validate FormData.submissionEvent
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 64, SubmissionIndicatorEvent);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.fields
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 72, 8, new codec.PointerTo(FormFieldData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.usernamePredictions
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 80, 4, codec.Uint32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FormData.encodedSize = codec.kStructHeaderSize + 88;

  FormData.decode = function(decoder) {
    var packed;
    var val = new FormData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.idAttribute = decoder.decodeStructPointer(string16$.String16);
    val.nameAttribute = decoder.decodeStructPointer(string16$.String16);
    val.name = decoder.decodeStructPointer(string16$.String16);
    val.buttonTitles = decoder.decodeArrayPointer(new codec.PointerTo(ButtonTitleInfo));
    val.url = decoder.decodeStructPointer(url$.Url);
    val.action = decoder.decodeStructPointer(url$.Url);
    packed = decoder.readUint8();
    val.isActionEmpty = (packed >> 0) & 1 ? true : false;
    val.isFormTag = (packed >> 1) & 1 ? true : false;
    val.isFormlessCheckout = (packed >> 2) & 1 ? true : false;
    val.isGaiaWithSkipSavePasswordForm = (packed >> 3) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.uniqueRendererId = decoder.decodeStruct(codec.Uint32);
    val.mainFrameOrigin = decoder.decodeStructPointer(origin$.Origin);
    val.submissionEvent = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.fields = decoder.decodeArrayPointer(new codec.PointerTo(FormFieldData));
    val.usernamePredictions = decoder.decodeArrayPointer(codec.Uint32);
    return val;
  };

  FormData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.idAttribute);
    encoder.encodeStructPointer(string16$.String16, val.nameAttribute);
    encoder.encodeStructPointer(string16$.String16, val.name);
    encoder.encodeArrayPointer(new codec.PointerTo(ButtonTitleInfo), val.buttonTitles);
    encoder.encodeStructPointer(url$.Url, val.url);
    encoder.encodeStructPointer(url$.Url, val.action);
    packed = 0;
    packed |= (val.isActionEmpty & 1) << 0
    packed |= (val.isFormTag & 1) << 1
    packed |= (val.isFormlessCheckout & 1) << 2
    packed |= (val.isGaiaWithSkipSavePasswordForm & 1) << 3
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint32, val.uniqueRendererId);
    encoder.encodeStructPointer(origin$.Origin, val.mainFrameOrigin);
    encoder.encodeStruct(codec.Int32, val.submissionEvent);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(FormFieldData), val.fields);
    encoder.encodeArrayPointer(codec.Uint32, val.usernamePredictions);
  };
  function FormFieldDataPredictions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormFieldDataPredictions.prototype.initDefaults_ = function() {
    this.field = null;
    this.signature = null;
    this.heuristicType = null;
    this.serverType = null;
    this.overallType = null;
    this.parseableName = null;
    this.section = null;
  };
  FormFieldDataPredictions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormFieldDataPredictions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.field
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FormFieldData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.signature
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.heuristicType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.serverType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 24, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.overallType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 32, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.parseableName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 40, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.section
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FormFieldDataPredictions.encodedSize = codec.kStructHeaderSize + 56;

  FormFieldDataPredictions.decode = function(decoder) {
    var packed;
    var val = new FormFieldDataPredictions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.field = decoder.decodeStructPointer(FormFieldData);
    val.signature = decoder.decodeStruct(codec.String);
    val.heuristicType = decoder.decodeStruct(codec.String);
    val.serverType = decoder.decodeStruct(codec.String);
    val.overallType = decoder.decodeStruct(codec.String);
    val.parseableName = decoder.decodeStruct(codec.String);
    val.section = decoder.decodeStruct(codec.String);
    return val;
  };

  FormFieldDataPredictions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormFieldDataPredictions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FormFieldData, val.field);
    encoder.encodeStruct(codec.String, val.signature);
    encoder.encodeStruct(codec.String, val.heuristicType);
    encoder.encodeStruct(codec.String, val.serverType);
    encoder.encodeStruct(codec.String, val.overallType);
    encoder.encodeStruct(codec.String, val.parseableName);
    encoder.encodeStruct(codec.String, val.section);
  };
  function FormDataPredictions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormDataPredictions.prototype.initDefaults_ = function() {
    this.data = null;
    this.signature = null;
    this.fields = null;
  };
  FormDataPredictions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormDataPredictions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FormData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.signature
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.fields
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(FormFieldDataPredictions), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FormDataPredictions.encodedSize = codec.kStructHeaderSize + 24;

  FormDataPredictions.decode = function(decoder) {
    var packed;
    var val = new FormDataPredictions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data = decoder.decodeStructPointer(FormData);
    val.signature = decoder.decodeStruct(codec.String);
    val.fields = decoder.decodeArrayPointer(new codec.PointerTo(FormFieldDataPredictions));
    return val;
  };

  FormDataPredictions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormDataPredictions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FormData, val.data);
    encoder.encodeStruct(codec.String, val.signature);
    encoder.encodeArrayPointer(new codec.PointerTo(FormFieldDataPredictions), val.fields);
  };
  function PasswordAndRealm(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordAndRealm.prototype.initDefaults_ = function() {
    this.password = null;
    this.realm = null;
  };
  PasswordAndRealm.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordAndRealm.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordAndRealm.password
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordAndRealm.realm
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PasswordAndRealm.encodedSize = codec.kStructHeaderSize + 16;

  PasswordAndRealm.decode = function(decoder) {
    var packed;
    var val = new PasswordAndRealm();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.password = decoder.decodeStructPointer(string16$.String16);
    val.realm = decoder.decodeStruct(codec.String);
    return val;
  };

  PasswordAndRealm.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordAndRealm.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.password);
    encoder.encodeStruct(codec.String, val.realm);
  };
  function PasswordFormFillData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordFormFillData.prototype.initDefaults_ = function() {
    this.formRendererId = 0;
    this.usernameMayUsePrefilledPlaceholder = false;
    this.waitForUsername = false;
    this.hasRendererIds = false;
    this.origin = null;
    this.action = null;
    this.usernameField = null;
    this.passwordField = null;
    this.preferredRealm = null;
    this.additionalLogins = null;
  };
  PasswordFormFillData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordFormFillData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordFormFillData.origin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.action
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.usernameField
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, FormFieldData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.passwordField
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, FormFieldData, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordFormFillData.preferredRealm
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 40, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.additionalLogins
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 48, false, new codec.PointerTo(string16$.String16), new codec.PointerTo(PasswordAndRealm), false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  PasswordFormFillData.encodedSize = codec.kStructHeaderSize + 56;

  PasswordFormFillData.decode = function(decoder) {
    var packed;
    var val = new PasswordFormFillData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.formRendererId = decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.usernameMayUsePrefilledPlaceholder = (packed >> 0) & 1 ? true : false;
    val.waitForUsername = (packed >> 1) & 1 ? true : false;
    val.hasRendererIds = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.origin = decoder.decodeStructPointer(url$.Url);
    val.action = decoder.decodeStructPointer(url$.Url);
    val.usernameField = decoder.decodeStructPointer(FormFieldData);
    val.passwordField = decoder.decodeStructPointer(FormFieldData);
    val.preferredRealm = decoder.decodeStruct(codec.String);
    val.additionalLogins = decoder.decodeMapPointer(new codec.PointerTo(string16$.String16), new codec.PointerTo(PasswordAndRealm));
    return val;
  };

  PasswordFormFillData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordFormFillData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.formRendererId);
    packed = 0;
    packed |= (val.usernameMayUsePrefilledPlaceholder & 1) << 0
    packed |= (val.waitForUsername & 1) << 1
    packed |= (val.hasRendererIds & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(url$.Url, val.origin);
    encoder.encodeStructPointer(url$.Url, val.action);
    encoder.encodeStructPointer(FormFieldData, val.usernameField);
    encoder.encodeStructPointer(FormFieldData, val.passwordField);
    encoder.encodeStruct(codec.String, val.preferredRealm);
    encoder.encodeMapPointer(new codec.PointerTo(string16$.String16), new codec.PointerTo(PasswordAndRealm), val.additionalLogins);
  };
  function PasswordFormGenerationData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordFormGenerationData.prototype.initDefaults_ = function() {
    this.newPasswordRendererId = 0;
    this.confirmationPasswordRendererId = 0;
  };
  PasswordFormGenerationData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordFormGenerationData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  PasswordFormGenerationData.encodedSize = codec.kStructHeaderSize + 8;

  PasswordFormGenerationData.decode = function(decoder) {
    var packed;
    var val = new PasswordFormGenerationData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.newPasswordRendererId = decoder.decodeStruct(codec.Uint32);
    val.confirmationPasswordRendererId = decoder.decodeStruct(codec.Uint32);
    return val;
  };

  PasswordFormGenerationData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordFormGenerationData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.newPasswordRendererId);
    encoder.encodeStruct(codec.Uint32, val.confirmationPasswordRendererId);
  };
  function PasswordGenerationUIData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordGenerationUIData.prototype.initDefaults_ = function() {
    this.bounds = null;
    this.maxLength = 0;
    this.generationElementId = 0;
    this.generationElement = null;
    this.textDirection = 0;
    this.passwordForm = null;
  };
  PasswordGenerationUIData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordGenerationUIData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordGenerationUIData.bounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordGenerationUIData.generationElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordGenerationUIData.textDirection
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 24, text_direction$.TextDirection);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordGenerationUIData.passwordForm
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, PasswordForm, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PasswordGenerationUIData.encodedSize = codec.kStructHeaderSize + 40;

  PasswordGenerationUIData.decode = function(decoder) {
    var packed;
    var val = new PasswordGenerationUIData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bounds = decoder.decodeStructPointer(geometry$.RectF);
    val.maxLength = decoder.decodeStruct(codec.Int32);
    val.generationElementId = decoder.decodeStruct(codec.Uint32);
    val.generationElement = decoder.decodeStructPointer(string16$.String16);
    val.textDirection = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.passwordForm = decoder.decodeStructPointer(PasswordForm);
    return val;
  };

  PasswordGenerationUIData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordGenerationUIData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.RectF, val.bounds);
    encoder.encodeStruct(codec.Int32, val.maxLength);
    encoder.encodeStruct(codec.Uint32, val.generationElementId);
    encoder.encodeStructPointer(string16$.String16, val.generationElement);
    encoder.encodeStruct(codec.Int32, val.textDirection);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(PasswordForm, val.passwordForm);
  };
  function ValueElementPair(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ValueElementPair.prototype.initDefaults_ = function() {
    this.value = null;
    this.fieldName = null;
  };
  ValueElementPair.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ValueElementPair.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ValueElementPair.value
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ValueElementPair.fieldName
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ValueElementPair.encodedSize = codec.kStructHeaderSize + 16;

  ValueElementPair.decode = function(decoder) {
    var packed;
    var val = new ValueElementPair();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value = decoder.decodeStructPointer(string16$.String16);
    val.fieldName = decoder.decodeStructPointer(string16$.String16);
    return val;
  };

  ValueElementPair.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ValueElementPair.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.value);
    encoder.encodeStructPointer(string16$.String16, val.fieldName);
  };
  function PasswordForm(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  PasswordForm.Scheme = {};
  PasswordForm.Scheme.kHtml = 0;
  PasswordForm.Scheme.kBasic = PasswordForm.Scheme.kHtml + 1;
  PasswordForm.Scheme.kDigest = PasswordForm.Scheme.kBasic + 1;
  PasswordForm.Scheme.kOther = PasswordForm.Scheme.kDigest + 1;
  PasswordForm.Scheme.kUsernameOnly = PasswordForm.Scheme.kOther + 1;
  PasswordForm.Scheme.MIN_VALUE = 0,
  PasswordForm.Scheme.MAX_VALUE = 4,

  PasswordForm.Scheme.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  PasswordForm.Scheme.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  PasswordForm.Type = {};
  PasswordForm.Type.kManual = 0;
  PasswordForm.Type.kGenerated = PasswordForm.Type.kManual + 1;
  PasswordForm.Type.kApi = PasswordForm.Type.kGenerated + 1;
  PasswordForm.Type.MIN_VALUE = 0,
  PasswordForm.Type.MAX_VALUE = 2,

  PasswordForm.Type.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  PasswordForm.Type.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  PasswordForm.GenerationUploadStatus = {};
  PasswordForm.GenerationUploadStatus.kNoSignalSent = 0;
  PasswordForm.GenerationUploadStatus.kPositiveSignalSent = PasswordForm.GenerationUploadStatus.kNoSignalSent + 1;
  PasswordForm.GenerationUploadStatus.kNegativeSignalSent = PasswordForm.GenerationUploadStatus.kPositiveSignalSent + 1;
  PasswordForm.GenerationUploadStatus.kUnknownStatus = 10;
  PasswordForm.GenerationUploadStatus.MIN_VALUE = 0,
  PasswordForm.GenerationUploadStatus.MAX_VALUE = 10,

  PasswordForm.GenerationUploadStatus.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 10:
      return true;
    }
    return false;
  };

  PasswordForm.GenerationUploadStatus.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  PasswordForm.prototype.initDefaults_ = function() {
    this.scheme = 0;
    this.usernameMarkedBySite = false;
    this.formHasAutofilledValue = false;
    this.newPasswordMarkedBySite = false;
    this.preferred = false;
    this.blacklistedByUser = false;
    this.skipZeroClick = false;
    this.wasParsedUsingAutofillPredictions = false;
    this.isPublicSuffixMatch = false;
    this.isAffiliationBasedMatch = false;
    this.onlyForFallback = false;
    this.signonRealm = null;
    this.originWithPath = null;
    this.action = null;
    this.affiliatedWebRealm = null;
    this.submitElement = null;
    this.usernameElement = null;
    this.usernameValue = null;
    this.allPossibleUsernames = null;
    this.allPossiblePasswords = null;
    this.passwordElement = null;
    this.passwordValue = null;
    this.newPasswordElement = null;
    this.newPasswordValue = null;
    this.confirmationPasswordElement = null;
    this.dateCreated = null;
    this.dateSynced = null;
    this.type = 0;
    this.timesUsed = 0;
    this.formData = null;
    this.generationUploadStatus = 0;
    this.submissionEvent = 0;
    this.displayName = null;
    this.iconUrl = null;
    this.federationOrigin = null;
  };
  PasswordForm.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordForm.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 192}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.scheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, PasswordForm.Scheme);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.signonRealm
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.originWithPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.action
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.affiliatedWebRealm
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 32, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.submitElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.usernameElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.usernameValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.allPossibleUsernames
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 64, 8, new codec.PointerTo(ValueElementPair), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.allPossiblePasswords
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 72, 8, new codec.PointerTo(ValueElementPair), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.passwordElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.passwordValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 88, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.newPasswordElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 96, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.newPasswordValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 104, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.confirmationPasswordElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 112, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.dateCreated
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 120, time$.Time, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.dateSynced
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 128, time$.Time, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 136, PasswordForm.Type);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordForm.formData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 144, FormData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.generationUploadStatus
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 152, PasswordForm.GenerationUploadStatus);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.displayName
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 160, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.iconUrl
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 168, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordForm.federationOrigin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 176, origin$.Origin, false);
    if (err !== validator.validationError.NONE)
        return err;






    // validate PasswordForm.submissionEvent
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 156, SubmissionIndicatorEvent);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PasswordForm.encodedSize = codec.kStructHeaderSize + 184;

  PasswordForm.decode = function(decoder) {
    var packed;
    var val = new PasswordForm();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.scheme = decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.usernameMarkedBySite = (packed >> 0) & 1 ? true : false;
    val.formHasAutofilledValue = (packed >> 1) & 1 ? true : false;
    val.newPasswordMarkedBySite = (packed >> 2) & 1 ? true : false;
    val.preferred = (packed >> 3) & 1 ? true : false;
    val.blacklistedByUser = (packed >> 4) & 1 ? true : false;
    val.skipZeroClick = (packed >> 5) & 1 ? true : false;
    val.wasParsedUsingAutofillPredictions = (packed >> 6) & 1 ? true : false;
    val.isPublicSuffixMatch = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.isAffiliationBasedMatch = (packed >> 0) & 1 ? true : false;
    val.onlyForFallback = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    val.signonRealm = decoder.decodeStruct(codec.String);
    val.originWithPath = decoder.decodeStructPointer(url$.Url);
    val.action = decoder.decodeStructPointer(url$.Url);
    val.affiliatedWebRealm = decoder.decodeStruct(codec.String);
    val.submitElement = decoder.decodeStructPointer(string16$.String16);
    val.usernameElement = decoder.decodeStructPointer(string16$.String16);
    val.usernameValue = decoder.decodeStructPointer(string16$.String16);
    val.allPossibleUsernames = decoder.decodeArrayPointer(new codec.PointerTo(ValueElementPair));
    val.allPossiblePasswords = decoder.decodeArrayPointer(new codec.PointerTo(ValueElementPair));
    val.passwordElement = decoder.decodeStructPointer(string16$.String16);
    val.passwordValue = decoder.decodeStructPointer(string16$.String16);
    val.newPasswordElement = decoder.decodeStructPointer(string16$.String16);
    val.newPasswordValue = decoder.decodeStructPointer(string16$.String16);
    val.confirmationPasswordElement = decoder.decodeStructPointer(string16$.String16);
    val.dateCreated = decoder.decodeStructPointer(time$.Time);
    val.dateSynced = decoder.decodeStructPointer(time$.Time);
    val.type = decoder.decodeStruct(codec.Int32);
    val.timesUsed = decoder.decodeStruct(codec.Int32);
    val.formData = decoder.decodeStructPointer(FormData);
    val.generationUploadStatus = decoder.decodeStruct(codec.Int32);
    val.submissionEvent = decoder.decodeStruct(codec.Int32);
    val.displayName = decoder.decodeStructPointer(string16$.String16);
    val.iconUrl = decoder.decodeStructPointer(url$.Url);
    val.federationOrigin = decoder.decodeStructPointer(origin$.Origin);
    return val;
  };

  PasswordForm.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordForm.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.scheme);
    packed = 0;
    packed |= (val.usernameMarkedBySite & 1) << 0
    packed |= (val.formHasAutofilledValue & 1) << 1
    packed |= (val.newPasswordMarkedBySite & 1) << 2
    packed |= (val.preferred & 1) << 3
    packed |= (val.blacklistedByUser & 1) << 4
    packed |= (val.skipZeroClick & 1) << 5
    packed |= (val.wasParsedUsingAutofillPredictions & 1) << 6
    packed |= (val.isPublicSuffixMatch & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.isAffiliationBasedMatch & 1) << 0
    packed |= (val.onlyForFallback & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.signonRealm);
    encoder.encodeStructPointer(url$.Url, val.originWithPath);
    encoder.encodeStructPointer(url$.Url, val.action);
    encoder.encodeStruct(codec.String, val.affiliatedWebRealm);
    encoder.encodeStructPointer(string16$.String16, val.submitElement);
    encoder.encodeStructPointer(string16$.String16, val.usernameElement);
    encoder.encodeStructPointer(string16$.String16, val.usernameValue);
    encoder.encodeArrayPointer(new codec.PointerTo(ValueElementPair), val.allPossibleUsernames);
    encoder.encodeArrayPointer(new codec.PointerTo(ValueElementPair), val.allPossiblePasswords);
    encoder.encodeStructPointer(string16$.String16, val.passwordElement);
    encoder.encodeStructPointer(string16$.String16, val.passwordValue);
    encoder.encodeStructPointer(string16$.String16, val.newPasswordElement);
    encoder.encodeStructPointer(string16$.String16, val.newPasswordValue);
    encoder.encodeStructPointer(string16$.String16, val.confirmationPasswordElement);
    encoder.encodeStructPointer(time$.Time, val.dateCreated);
    encoder.encodeStructPointer(time$.Time, val.dateSynced);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.encodeStruct(codec.Int32, val.timesUsed);
    encoder.encodeStructPointer(FormData, val.formData);
    encoder.encodeStruct(codec.Int32, val.generationUploadStatus);
    encoder.encodeStruct(codec.Int32, val.submissionEvent);
    encoder.encodeStructPointer(string16$.String16, val.displayName);
    encoder.encodeStructPointer(url$.Url, val.iconUrl);
    encoder.encodeStructPointer(origin$.Origin, val.federationOrigin);
  };
  function ParsingResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ParsingResult.prototype.initDefaults_ = function() {
    this.usernameRendererId = 0;
    this.passwordRendererId = 0;
    this.newPasswordRendererId = 0;
    this.confirmPasswordRendererId = 0;
  };
  ParsingResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ParsingResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  ParsingResult.encodedSize = codec.kStructHeaderSize + 16;

  ParsingResult.decode = function(decoder) {
    var packed;
    var val = new ParsingResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.usernameRendererId = decoder.decodeStruct(codec.Uint32);
    val.passwordRendererId = decoder.decodeStruct(codec.Uint32);
    val.newPasswordRendererId = decoder.decodeStruct(codec.Uint32);
    val.confirmPasswordRendererId = decoder.decodeStruct(codec.Uint32);
    return val;
  };

  ParsingResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ParsingResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.usernameRendererId);
    encoder.encodeStruct(codec.Uint32, val.passwordRendererId);
    encoder.encodeStruct(codec.Uint32, val.newPasswordRendererId);
    encoder.encodeStruct(codec.Uint32, val.confirmPasswordRendererId);
  };
  exports.SubmissionIndicatorEvent = SubmissionIndicatorEvent;
  exports.PasswordFormFieldPredictionType = PasswordFormFieldPredictionType;
  exports.SubmissionSource = SubmissionSource;
  exports.FocusedFieldType = FocusedFieldType;
  exports.ButtonTitleType = ButtonTitleType;
  exports.AutofillState = AutofillState;
  exports.FormFieldData = FormFieldData;
  exports.ButtonTitleInfo = ButtonTitleInfo;
  exports.FormData = FormData;
  exports.FormFieldDataPredictions = FormFieldDataPredictions;
  exports.FormDataPredictions = FormDataPredictions;
  exports.PasswordAndRealm = PasswordAndRealm;
  exports.PasswordFormFillData = PasswordFormFillData;
  exports.PasswordFormGenerationData = PasswordFormGenerationData;
  exports.PasswordGenerationUIData = PasswordGenerationUIData;
  exports.ValueElementPair = ValueElementPair;
  exports.PasswordForm = PasswordForm;
  exports.ParsingResult = ParsingResult;
})();