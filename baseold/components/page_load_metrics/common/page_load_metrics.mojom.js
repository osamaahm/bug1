// components/page_load_metrics/common/page_load_metrics.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/page_load_metrics/common/page_load_metrics.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('pageLoadMetrics.mojom');
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../mojo/public/mojom/base/time.mojom.js');
  }
  var web_feature$ =
      mojo.internal.exposeNamespace('blink.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'third_party/blink/public/mojom/web_feature/web_feature.mojom', '../../../third_party/blink/public/mojom/web_feature/web_feature.mojom.js');
  }
  var css_property_id$ =
      mojo.internal.exposeNamespace('blink.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'third_party/blink/public/mojom/use_counter/css_property_id.mojom', '../../../third_party/blink/public/mojom/use_counter/css_property_id.mojom.js');
  }
  var origin$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/origin.mojom', '../../../url/mojom/origin.mojom.js');
  }


  var CacheType = {};
  CacheType.kNotCached = 0;
  CacheType.kHttp = CacheType.kNotCached + 1;
  CacheType.kMemory = CacheType.kHttp + 1;
  CacheType.MIN_VALUE = 0,
  CacheType.MAX_VALUE = 2,

  CacheType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  CacheType.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function DocumentTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DocumentTiming.prototype.initDefaults_ = function() {
    this.domContentLoadedEventStart = null;
    this.loadEventStart = null;
    this.firstLayout = null;
  };
  DocumentTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DocumentTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DocumentTiming.domContentLoadedEventStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DocumentTiming.loadEventStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DocumentTiming.firstLayout
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DocumentTiming.encodedSize = codec.kStructHeaderSize + 24;

  DocumentTiming.decode = function(decoder) {
    var packed;
    var val = new DocumentTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.domContentLoadedEventStart = decoder.decodeStructPointer(time$.TimeDelta);
    val.loadEventStart = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstLayout = decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  DocumentTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DocumentTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.domContentLoadedEventStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.loadEventStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstLayout);
  };
  function PaintTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PaintTiming.prototype.initDefaults_ = function() {
    this.firstPaint = null;
    this.firstImagePaint = null;
    this.firstContentfulPaint = null;
    this.firstMeaningfulPaint = null;
    this.largestImagePaint = null;
    this.largestImagePaintSize = 0;
    this.largestTextPaint = null;
    this.largestTextPaintSize = 0;
  };
  PaintTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PaintTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 72}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstImagePaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstContentfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstMeaningfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.largestImagePaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PaintTiming.largestTextPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PaintTiming.encodedSize = codec.kStructHeaderSize + 64;

  PaintTiming.decode = function(decoder) {
    var packed;
    var val = new PaintTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.firstPaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstImagePaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstContentfulPaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstMeaningfulPaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImagePaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImagePaintSize = decoder.decodeStruct(codec.Uint64);
    val.largestTextPaint = decoder.decodeStructPointer(time$.TimeDelta);
    val.largestTextPaintSize = decoder.decodeStruct(codec.Uint64);
    return val;
  };

  PaintTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PaintTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstImagePaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstContentfulPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstMeaningfulPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestImagePaint);
    encoder.encodeStruct(codec.Uint64, val.largestImagePaintSize);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestTextPaint);
    encoder.encodeStruct(codec.Uint64, val.largestTextPaintSize);
  };
  function ParseTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ParseTiming.prototype.initDefaults_ = function() {
    this.parseStart = null;
    this.parseStop = null;
    this.parseBlockedOnScriptLoadDuration = null;
    this.parseBlockedOnScriptLoadFromDocumentWriteDuration = null;
    this.parseBlockedOnScriptExecutionDuration = null;
    this.parseBlockedOnScriptExecutionFromDocumentWriteDuration = null;
  };
  ParseTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ParseTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseStop
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptLoadDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptLoadFromDocumentWriteDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptExecutionDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptExecutionFromDocumentWriteDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ParseTiming.encodedSize = codec.kStructHeaderSize + 48;

  ParseTiming.decode = function(decoder) {
    var packed;
    var val = new ParseTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.parseStart = decoder.decodeStructPointer(time$.TimeDelta);
    val.parseStop = decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptLoadDuration = decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptLoadFromDocumentWriteDuration = decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptExecutionDuration = decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptExecutionFromDocumentWriteDuration = decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  ParseTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ParseTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseStop);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptLoadDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptLoadFromDocumentWriteDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptExecutionDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptExecutionFromDocumentWriteDuration);
  };
  function InteractiveTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InteractiveTiming.prototype.initDefaults_ = function() {
    this.interactive = null;
    this.interactiveDetection = null;
    this.firstInvalidatingInput = null;
    this.firstInputDelay = null;
    this.firstInputTimestamp = null;
    this.longestInputDelay = null;
    this.longestInputTimestamp = null;
  };
  InteractiveTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InteractiveTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.interactive
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.interactiveDetection
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInvalidatingInput
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInputTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.longestInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.longestInputTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InteractiveTiming.encodedSize = codec.kStructHeaderSize + 56;

  InteractiveTiming.decode = function(decoder) {
    var packed;
    var val = new InteractiveTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.interactive = decoder.decodeStructPointer(time$.TimeDelta);
    val.interactiveDetection = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInvalidatingInput = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInputDelay = decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInputTimestamp = decoder.decodeStructPointer(time$.TimeDelta);
    val.longestInputDelay = decoder.decodeStructPointer(time$.TimeDelta);
    val.longestInputTimestamp = decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  InteractiveTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InteractiveTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.interactive);
    encoder.encodeStructPointer(time$.TimeDelta, val.interactiveDetection);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInvalidatingInput);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputTimestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.longestInputDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.longestInputTimestamp);
  };
  function PageLoadTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadTiming.prototype.initDefaults_ = function() {
    this.navigationStart = null;
    this.responseStart = null;
    this.documentTiming = null;
    this.interactiveTiming = null;
    this.paintTiming = null;
    this.parseTiming = null;
    this.inputToNavigationStart = null;
  };
  PageLoadTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.navigationStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.Time, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.responseStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.documentTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, DocumentTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.interactiveTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, InteractiveTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.paintTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, PaintTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.parseTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, ParseTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.inputToNavigationStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadTiming.encodedSize = codec.kStructHeaderSize + 56;

  PageLoadTiming.decode = function(decoder) {
    var packed;
    var val = new PageLoadTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.navigationStart = decoder.decodeStructPointer(time$.Time);
    val.responseStart = decoder.decodeStructPointer(time$.TimeDelta);
    val.documentTiming = decoder.decodeStructPointer(DocumentTiming);
    val.interactiveTiming = decoder.decodeStructPointer(InteractiveTiming);
    val.paintTiming = decoder.decodeStructPointer(PaintTiming);
    val.parseTiming = decoder.decodeStructPointer(ParseTiming);
    val.inputToNavigationStart = decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  PageLoadTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.Time, val.navigationStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.responseStart);
    encoder.encodeStructPointer(DocumentTiming, val.documentTiming);
    encoder.encodeStructPointer(InteractiveTiming, val.interactiveTiming);
    encoder.encodeStructPointer(PaintTiming, val.paintTiming);
    encoder.encodeStructPointer(ParseTiming, val.parseTiming);
    encoder.encodeStructPointer(time$.TimeDelta, val.inputToNavigationStart);
  };
  function PageLoadMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadMetadata.prototype.initDefaults_ = function() {
    this.behaviorFlags = 0;
  };
  PageLoadMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PageLoadMetadata.encodedSize = codec.kStructHeaderSize + 8;

  PageLoadMetadata.decode = function(decoder) {
    var packed;
    var val = new PageLoadMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.behaviorFlags = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PageLoadMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadMetadata.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.behaviorFlags);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function PageLoadFeatures(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadFeatures.prototype.initDefaults_ = function() {
    this.features = null;
    this.cssProperties = null;
    this.animatedCssProperties = null;
  };
  PageLoadFeatures.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadFeatures.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadFeatures.features
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 4, new codec.Enum(web_feature$.WebFeature), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadFeatures.cssProperties
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, new codec.Enum(css_property_id$.CSSSampleId), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadFeatures.animatedCssProperties
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 4, new codec.Enum(css_property_id$.CSSSampleId), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadFeatures.encodedSize = codec.kStructHeaderSize + 24;

  PageLoadFeatures.decode = function(decoder) {
    var packed;
    var val = new PageLoadFeatures();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.features = decoder.decodeArrayPointer(new codec.Enum(web_feature$.WebFeature));
    val.cssProperties = decoder.decodeArrayPointer(new codec.Enum(css_property_id$.CSSSampleId));
    val.animatedCssProperties = decoder.decodeArrayPointer(new codec.Enum(css_property_id$.CSSSampleId));
    return val;
  };

  PageLoadFeatures.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadFeatures.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.Enum(web_feature$.WebFeature), val.features);
    encoder.encodeArrayPointer(new codec.Enum(css_property_id$.CSSSampleId), val.cssProperties);
    encoder.encodeArrayPointer(new codec.Enum(css_property_id$.CSSSampleId), val.animatedCssProperties);
  };
  function ResourceDataUpdate(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ResourceDataUpdate.prototype.initDefaults_ = function() {
    this.requestId = 0;
    this.isComplete = false;
    this.reportedAsAdResource = false;
    this.isMainFrameResource = false;
    this.isPrimaryFrameResource = false;
    this.isSecureScheme = false;
    this.proxyUsed = false;
    this.completedBeforeFcp = false;
    this.deltaBytes = 0;
    this.receivedDataLength = 0;
    this.encodedBodyLength = 0;
    this.dataReductionProxyCompressionRatioEstimate = 0;
    this.cacheType = 0;
    this.mimeType = null;
    this.origin = null;
  };
  ResourceDataUpdate.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ResourceDataUpdate.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 72}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;










    // validate ResourceDataUpdate.cacheType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 40, CacheType);
    if (err !== validator.validationError.NONE)
        return err;



    // validate ResourceDataUpdate.mimeType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;




    // validate ResourceDataUpdate.origin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, origin$.Origin, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  ResourceDataUpdate.encodedSize = codec.kStructHeaderSize + 64;

  ResourceDataUpdate.decode = function(decoder) {
    var packed;
    var val = new ResourceDataUpdate();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.requestId = decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isComplete = (packed >> 0) & 1 ? true : false;
    val.reportedAsAdResource = (packed >> 1) & 1 ? true : false;
    val.isMainFrameResource = (packed >> 2) & 1 ? true : false;
    val.isPrimaryFrameResource = (packed >> 3) & 1 ? true : false;
    val.isSecureScheme = (packed >> 4) & 1 ? true : false;
    val.proxyUsed = (packed >> 5) & 1 ? true : false;
    val.completedBeforeFcp = (packed >> 6) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.deltaBytes = decoder.decodeStruct(codec.Int64);
    val.receivedDataLength = decoder.decodeStruct(codec.Int64);
    val.encodedBodyLength = decoder.decodeStruct(codec.Int64);
    val.dataReductionProxyCompressionRatioEstimate = decoder.decodeStruct(codec.Double);
    val.cacheType = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mimeType = decoder.decodeStruct(codec.String);
    val.origin = decoder.decodeStructPointer(origin$.Origin);
    return val;
  };

  ResourceDataUpdate.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ResourceDataUpdate.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.requestId);
    packed = 0;
    packed |= (val.isComplete & 1) << 0
    packed |= (val.reportedAsAdResource & 1) << 1
    packed |= (val.isMainFrameResource & 1) << 2
    packed |= (val.isPrimaryFrameResource & 1) << 3
    packed |= (val.isSecureScheme & 1) << 4
    packed |= (val.proxyUsed & 1) << 5
    packed |= (val.completedBeforeFcp & 1) << 6
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int64, val.deltaBytes);
    encoder.encodeStruct(codec.Int64, val.receivedDataLength);
    encoder.encodeStruct(codec.Int64, val.encodedBodyLength);
    encoder.encodeStruct(codec.Double, val.dataReductionProxyCompressionRatioEstimate);
    encoder.encodeStruct(codec.Int32, val.cacheType);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.mimeType);
    encoder.encodeStructPointer(origin$.Origin, val.origin);
  };
  function FrameRenderDataUpdate(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FrameRenderDataUpdate.prototype.initDefaults_ = function() {
    this.layoutShiftDelta = 0;
    this.layoutShiftDeltaBeforeInputOrScroll = 0;
  };
  FrameRenderDataUpdate.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FrameRenderDataUpdate.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  FrameRenderDataUpdate.encodedSize = codec.kStructHeaderSize + 8;

  FrameRenderDataUpdate.decode = function(decoder) {
    var packed;
    var val = new FrameRenderDataUpdate();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.layoutShiftDelta = decoder.decodeStruct(codec.Float);
    val.layoutShiftDeltaBeforeInputOrScroll = decoder.decodeStruct(codec.Float);
    return val;
  };

  FrameRenderDataUpdate.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FrameRenderDataUpdate.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.layoutShiftDelta);
    encoder.encodeStruct(codec.Float, val.layoutShiftDeltaBeforeInputOrScroll);
  };
  function CpuTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CpuTiming.prototype.initDefaults_ = function() {
    this.taskTime = null;
  };
  CpuTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CpuTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CpuTiming.taskTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CpuTiming.encodedSize = codec.kStructHeaderSize + 8;

  CpuTiming.decode = function(decoder) {
    var packed;
    var val = new CpuTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.taskTime = decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  CpuTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CpuTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.taskTime);
  };
  function DeferredResourceCounts(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DeferredResourceCounts.prototype.initDefaults_ = function() {
    this.deferredFrames = 0;
    this.framesLoadedAfterDeferral = 0;
    this.deferredImages = 0;
    this.imagesLoadedAfterDeferral = 0;
  };
  DeferredResourceCounts.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DeferredResourceCounts.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  DeferredResourceCounts.encodedSize = codec.kStructHeaderSize + 32;

  DeferredResourceCounts.decode = function(decoder) {
    var packed;
    var val = new DeferredResourceCounts();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.deferredFrames = decoder.decodeStruct(codec.Uint64);
    val.framesLoadedAfterDeferral = decoder.decodeStruct(codec.Uint64);
    val.deferredImages = decoder.decodeStruct(codec.Uint64);
    val.imagesLoadedAfterDeferral = decoder.decodeStruct(codec.Uint64);
    return val;
  };

  DeferredResourceCounts.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DeferredResourceCounts.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.deferredFrames);
    encoder.encodeStruct(codec.Uint64, val.framesLoadedAfterDeferral);
    encoder.encodeStruct(codec.Uint64, val.deferredImages);
    encoder.encodeStruct(codec.Uint64, val.imagesLoadedAfterDeferral);
  };
  function PageLoadMetrics_UpdateTiming_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadMetrics_UpdateTiming_Params.prototype.initDefaults_ = function() {
    this.pageLoadTiming = null;
    this.pageLoadMetadata = null;
    this.newFeatures = null;
    this.resources = null;
    this.renderData = null;
    this.cpuLoadTiming = null;
    this.newDeferredResourceData = null;
  };
  PageLoadMetrics_UpdateTiming_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadMetrics_UpdateTiming_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.pageLoadTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, PageLoadTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.pageLoadMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, PageLoadMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.newFeatures
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, PageLoadFeatures, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.resources
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(ResourceDataUpdate), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.renderData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, FrameRenderDataUpdate, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.cpuLoadTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, CpuTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.newDeferredResourceData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, DeferredResourceCounts, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadMetrics_UpdateTiming_Params.encodedSize = codec.kStructHeaderSize + 56;

  PageLoadMetrics_UpdateTiming_Params.decode = function(decoder) {
    var packed;
    var val = new PageLoadMetrics_UpdateTiming_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pageLoadTiming = decoder.decodeStructPointer(PageLoadTiming);
    val.pageLoadMetadata = decoder.decodeStructPointer(PageLoadMetadata);
    val.newFeatures = decoder.decodeStructPointer(PageLoadFeatures);
    val.resources = decoder.decodeArrayPointer(new codec.PointerTo(ResourceDataUpdate));
    val.renderData = decoder.decodeStructPointer(FrameRenderDataUpdate);
    val.cpuLoadTiming = decoder.decodeStructPointer(CpuTiming);
    val.newDeferredResourceData = decoder.decodeStructPointer(DeferredResourceCounts);
    return val;
  };

  PageLoadMetrics_UpdateTiming_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadMetrics_UpdateTiming_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(PageLoadTiming, val.pageLoadTiming);
    encoder.encodeStructPointer(PageLoadMetadata, val.pageLoadMetadata);
    encoder.encodeStructPointer(PageLoadFeatures, val.newFeatures);
    encoder.encodeArrayPointer(new codec.PointerTo(ResourceDataUpdate), val.resources);
    encoder.encodeStructPointer(FrameRenderDataUpdate, val.renderData);
    encoder.encodeStructPointer(CpuTiming, val.cpuLoadTiming);
    encoder.encodeStructPointer(DeferredResourceCounts, val.newDeferredResourceData);
  };
  var kPageLoadMetrics_UpdateTiming_Name = 0;

  function PageLoadMetricsPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(PageLoadMetrics,
                                                   handleOrPtrInfo);
  }

  function PageLoadMetricsAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        PageLoadMetrics, associatedInterfacePtrInfo);
  }

  PageLoadMetricsAssociatedPtr.prototype =
      Object.create(PageLoadMetricsPtr.prototype);
  PageLoadMetricsAssociatedPtr.prototype.constructor =
      PageLoadMetricsAssociatedPtr;

  function PageLoadMetricsProxy(receiver) {
    this.receiver_ = receiver;
  }
  PageLoadMetricsPtr.prototype.updateTiming = function() {
    return PageLoadMetricsProxy.prototype.updateTiming
        .apply(this.ptr.getProxy(), arguments);
  };

  PageLoadMetricsProxy.prototype.updateTiming = function(pageLoadTiming, pageLoadMetadata, newFeatures, resources, renderData, cpuLoadTiming, newDeferredResourceData) {
    var params_ = new PageLoadMetrics_UpdateTiming_Params();
    params_.pageLoadTiming = pageLoadTiming;
    params_.pageLoadMetadata = pageLoadMetadata;
    params_.newFeatures = newFeatures;
    params_.resources = resources;
    params_.renderData = renderData;
    params_.cpuLoadTiming = cpuLoadTiming;
    params_.newDeferredResourceData = newDeferredResourceData;
    var builder = new codec.MessageV0Builder(
        kPageLoadMetrics_UpdateTiming_Name,
        codec.align(PageLoadMetrics_UpdateTiming_Params.encodedSize));
    builder.encodeStruct(PageLoadMetrics_UpdateTiming_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function PageLoadMetricsStub(delegate) {
    this.delegate_ = delegate;
  }
  PageLoadMetricsStub.prototype.updateTiming = function(pageLoadTiming, pageLoadMetadata, newFeatures, resources, renderData, cpuLoadTiming, newDeferredResourceData) {
    return this.delegate_ && this.delegate_.updateTiming && this.delegate_.updateTiming(pageLoadTiming, pageLoadMetadata, newFeatures, resources, renderData, cpuLoadTiming, newDeferredResourceData);
  }

  PageLoadMetricsStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kPageLoadMetrics_UpdateTiming_Name:
      var params = reader.decodeStruct(PageLoadMetrics_UpdateTiming_Params);
      this.updateTiming(params.pageLoadTiming, params.pageLoadMetadata, params.newFeatures, params.resources, params.renderData, params.cpuLoadTiming, params.newDeferredResourceData);
      return true;
    default:
      return false;
    }
  };

  PageLoadMetricsStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validatePageLoadMetricsRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kPageLoadMetrics_UpdateTiming_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = PageLoadMetrics_UpdateTiming_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validatePageLoadMetricsResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var PageLoadMetrics = {
    name: 'page_load_metrics.mojom.PageLoadMetrics',
    kVersion: 0,
    ptrClass: PageLoadMetricsPtr,
    proxyClass: PageLoadMetricsProxy,
    stubClass: PageLoadMetricsStub,
    validateRequest: validatePageLoadMetricsRequest,
    validateResponse: null,
  };
  PageLoadMetricsStub.prototype.validator = validatePageLoadMetricsRequest;
  PageLoadMetricsProxy.prototype.validator = null;
  exports.CacheType = CacheType;
  exports.DocumentTiming = DocumentTiming;
  exports.PaintTiming = PaintTiming;
  exports.ParseTiming = ParseTiming;
  exports.InteractiveTiming = InteractiveTiming;
  exports.PageLoadTiming = PageLoadTiming;
  exports.PageLoadMetadata = PageLoadMetadata;
  exports.PageLoadFeatures = PageLoadFeatures;
  exports.ResourceDataUpdate = ResourceDataUpdate;
  exports.FrameRenderDataUpdate = FrameRenderDataUpdate;
  exports.CpuTiming = CpuTiming;
  exports.DeferredResourceCounts = DeferredResourceCounts;
  exports.PageLoadMetrics = PageLoadMetrics;
  exports.PageLoadMetricsPtr = PageLoadMetricsPtr;
  exports.PageLoadMetricsAssociatedPtr = PageLoadMetricsAssociatedPtr;
})();